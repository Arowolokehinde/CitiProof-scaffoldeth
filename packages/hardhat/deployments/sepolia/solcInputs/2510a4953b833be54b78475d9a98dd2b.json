{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "contracts/CitizenIdentityRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\n/**\n * @title CitizenIdentityRegistry\n * @dev Manages verified citizen identities and their verification levels\n * @author CitiProof Team\n */\ncontract CitizenIdentityRegistry is Ownable, ReentrancyGuard {\n    // Counter for citizen IDs (using simple uint256 instead of Counters)\n    uint256 private _citizenIdCounter;\n\n    // Verification levels\n    enum VerificationLevel {\n        UNVERIFIED,    // Default state\n        BASIC,         // Basic wallet connection + EFP\n        VERIFIED,      // Enhanced verification (50+ EFP followers)\n        PREMIUM        // Government-verified or high reputation\n    }\n\n    // Citizen profile structure\n    struct CitizenProfile {\n        uint256 citizenId;\n        address walletAddress;\n        string ensName;              // ENS name if available\n        string efpTokenId;           // EFP list token ID\n        uint256 efpFollowers;        // EFP follower count\n        uint256 efpFollowing;        // EFP following count\n        VerificationLevel verificationLevel;\n        uint256 registrationTimestamp;\n        uint256 lastUpdateTimestamp;\n        bool isActive;\n        uint256 reputationScore;     // Link to reputation contract\n        string ipfsMetadata;         // Additional profile data on IPFS\n    }\n\n    // Storage mappings\n    mapping(address => uint256) public walletToCitizenId;\n    mapping(uint256 => CitizenProfile) public citizens;\n    mapping(string => uint256) public ensNameToCitizenId;\n    mapping(string => bool) public registeredEnsNames;\n\n    // Events\n    event CitizenRegistered(\n        uint256 indexed citizenId,\n        address indexed walletAddress,\n        string ensName,\n        VerificationLevel verificationLevel\n    );\n\n    event CitizenVerificationUpdated(\n        uint256 indexed citizenId,\n        address indexed walletAddress,\n        VerificationLevel oldLevel,\n        VerificationLevel newLevel\n    );\n\n    event CitizenProfileUpdated(\n        uint256 indexed citizenId,\n        address indexed walletAddress,\n        string ensName,\n        string efpTokenId\n    );\n\n    event CitizenDeactivated(\n        uint256 indexed citizenId,\n        address indexed walletAddress,\n        address indexed deactivatedBy\n    );\n\n    // Modifiers\n    modifier onlyRegisteredCitizen() {\n        require(walletToCitizenId[msg.sender] != 0, \"CitizenRegistry: Caller is not a registered citizen\");\n        require(citizens[walletToCitizenId[msg.sender]].isActive, \"CitizenRegistry: Citizen account is not active\");\n        _;\n    }\n\n    modifier validCitizenId(uint256 _citizenId) {\n        require(_citizenId > 0 && _citizenId <= _citizenIdCounter, \"CitizenRegistry: Invalid citizen ID\");\n        _;\n    }\n\n    modifier onlyActiveCitizen(uint256 _citizenId) {\n        require(citizens[_citizenId].isActive, \"CitizenRegistry: Citizen is not active\");\n        _;\n    }\n\n    constructor(address initialOwner) Ownable(initialOwner) {}\n\n    /**\n     * @dev Register a new citizen with flexible requirements\n     * @param _ensName ENS name (can be empty string for wallet-only registration)\n     * @param _efpTokenId EFP list token ID (can be empty string)\n     * @param _efpFollowers Number of EFP followers (0 allowed for new users)\n     * @param _efpFollowing Number of EFP following (0 allowed for new users)\n     * @param _ipfsMetadata IPFS hash for additional profile data\n     */\n    function registerCitizen(\n        string memory _ensName,\n        string memory _efpTokenId,\n        uint256 _efpFollowers,\n        uint256 _efpFollowing,\n        string memory _ipfsMetadata\n    ) external nonReentrant {\n        require(walletToCitizenId[msg.sender] == 0, \"CitizenRegistry: Wallet already registered\");\n        \n        // Check if ENS name is already taken (if provided)\n        if (bytes(_ensName).length > 0) {\n            require(!registeredEnsNames[_ensName], \"CitizenRegistry: ENS name already registered\");\n        }\n\n        // Increment citizen ID counter\n        _citizenIdCounter++;\n        uint256 newCitizenId = _citizenIdCounter;\n\n        // Determine verification level based on EFP data\n        VerificationLevel verificationLevel = _determineVerificationLevel(_efpFollowers, _efpFollowing);\n\n        // Create citizen profile\n        citizens[newCitizenId] = CitizenProfile({\n            citizenId: newCitizenId,\n            walletAddress: msg.sender,\n            ensName: _ensName,\n            efpTokenId: _efpTokenId,\n            efpFollowers: _efpFollowers,\n            efpFollowing: _efpFollowing,\n            verificationLevel: verificationLevel,\n            registrationTimestamp: block.timestamp,\n            lastUpdateTimestamp: block.timestamp,\n            isActive: true,\n            reputationScore: 0, // Will be updated by reputation contract\n            ipfsMetadata: _ipfsMetadata\n        });\n\n        // Update mappings\n        walletToCitizenId[msg.sender] = newCitizenId;\n        if (bytes(_ensName).length > 0) {\n            ensNameToCitizenId[_ensName] = newCitizenId;\n            registeredEnsNames[_ensName] = true;\n        }\n\n        emit CitizenRegistered(newCitizenId, msg.sender, _ensName, verificationLevel);\n    }\n\n    /**\n     * @dev Simplified registration for wallet-only users (hackathon-friendly)\n     * Automatically generates ENS subdomain and placeholder EFP data\n     */\n    function registerCitizenSimple() external nonReentrant {\n        require(walletToCitizenId[msg.sender] == 0, \"CitizenRegistry: Wallet already registered\");\n\n        // Generate automatic ENS subdomain using last 6 chars of address\n        string memory addressSuffix = Strings.toHexString(uint160(msg.sender) & 0xFFFFFF, 3);\n        string memory autoEnsName = string(abi.encodePacked(\"citizen\", addressSuffix, \".citiproof.eth\"));\n        \n        // Ensure generated name is unique (highly unlikely to collide)\n        require(!registeredEnsNames[autoEnsName], \"CitizenRegistry: Generated ENS name collision\");\n\n        // Create with minimal verification data (can be updated later)\n        _citizenIdCounter++;\n        uint256 newCitizenId = _citizenIdCounter;\n\n        citizens[newCitizenId] = CitizenProfile({\n            citizenId: newCitizenId,\n            walletAddress: msg.sender,\n            ensName: autoEnsName,\n            efpTokenId: \"\", // Can be added later\n            efpFollowers: 0,\n            efpFollowing: 0,\n            verificationLevel: VerificationLevel.UNVERIFIED,\n            registrationTimestamp: block.timestamp,\n            lastUpdateTimestamp: block.timestamp,\n            isActive: true,\n            reputationScore: 0,\n            ipfsMetadata: \"\"\n        });\n\n        // Update mappings\n        walletToCitizenId[msg.sender] = newCitizenId;\n        ensNameToCitizenId[autoEnsName] = newCitizenId;\n        registeredEnsNames[autoEnsName] = true;\n\n        emit CitizenRegistered(newCitizenId, msg.sender, autoEnsName, VerificationLevel.UNVERIFIED);\n    }\n\n    /**\n     * @dev Update citizen's EFP verification data\n     * @param _efpTokenId New EFP token ID\n     * @param _efpFollowers Updated follower count\n     * @param _efpFollowing Updated following count\n     */\n    function updateEFPVerification(\n        string memory _efpTokenId,\n        uint256 _efpFollowers,\n        uint256 _efpFollowing\n    ) external onlyRegisteredCitizen {\n        uint256 citizenId = walletToCitizenId[msg.sender];\n        CitizenProfile storage citizen = citizens[citizenId];\n\n        VerificationLevel oldLevel = citizen.verificationLevel;\n        VerificationLevel newLevel = _determineVerificationLevel(_efpFollowers, _efpFollowing);\n\n        // Update EFP data\n        citizen.efpTokenId = _efpTokenId;\n        citizen.efpFollowers = _efpFollowers;\n        citizen.efpFollowing = _efpFollowing;\n        citizen.verificationLevel = newLevel;\n        citizen.lastUpdateTimestamp = block.timestamp;\n\n        if (oldLevel != newLevel) {\n            emit CitizenVerificationUpdated(citizenId, msg.sender, oldLevel, newLevel);\n        }\n\n        emit CitizenProfileUpdated(citizenId, msg.sender, citizen.ensName, _efpTokenId);\n    }\n\n    /**\n     * @dev Update citizen's ENS name\n     * @param _ensName New ENS name\n     */\n    function updateENSName(string memory _ensName) external onlyRegisteredCitizen {\n        require(bytes(_ensName).length > 0, \"CitizenRegistry: ENS name cannot be empty\");\n        require(!registeredEnsNames[_ensName], \"CitizenRegistry: ENS name already registered\");\n\n        uint256 citizenId = walletToCitizenId[msg.sender];\n        CitizenProfile storage citizen = citizens[citizenId];\n\n        // Remove old ENS name from registry\n        if (bytes(citizen.ensName).length > 0) {\n            registeredEnsNames[citizen.ensName] = false;\n            delete ensNameToCitizenId[citizen.ensName];\n        }\n\n        // Set new ENS name\n        citizen.ensName = _ensName;\n        citizen.lastUpdateTimestamp = block.timestamp;\n        ensNameToCitizenId[_ensName] = citizenId;\n        registeredEnsNames[_ensName] = true;\n\n        emit CitizenProfileUpdated(citizenId, msg.sender, _ensName, citizen.efpTokenId);\n    }\n\n    /**\n     * @dev Update reputation score (only called by reputation contract)\n     * @param _citizenId Citizen ID\n     * @param _reputationScore New reputation score\n     */\n    function updateReputationScore(\n        uint256 _citizenId,\n        uint256 _reputationScore\n    ) external validCitizenId(_citizenId) {\n        // TODO: Add access control for reputation contract\n        // require(msg.sender == reputationContract, \"CitizenRegistry: Only reputation contract can update scores\");\n        \n        citizens[_citizenId].reputationScore = _reputationScore;\n        citizens[_citizenId].lastUpdateTimestamp = block.timestamp;\n\n        // Check if reputation score qualifies for premium verification\n        if (_reputationScore >= 1000 && citizens[_citizenId].verificationLevel != VerificationLevel.PREMIUM) {\n            VerificationLevel oldLevel = citizens[_citizenId].verificationLevel;\n            citizens[_citizenId].verificationLevel = VerificationLevel.PREMIUM;\n            emit CitizenVerificationUpdated(\n                _citizenId, \n                citizens[_citizenId].walletAddress, \n                oldLevel, \n                VerificationLevel.PREMIUM\n            );\n        }\n    }\n\n    /**\n     * @dev Deactivate a citizen account (admin function)\n     * @param _citizenId Citizen ID to deactivate\n     */\n    function deactivateCitizen(uint256 _citizenId) external onlyOwner validCitizenId(_citizenId) {\n        citizens[_citizenId].isActive = false;\n        citizens[_citizenId].lastUpdateTimestamp = block.timestamp;\n\n        emit CitizenDeactivated(\n            _citizenId,\n            citizens[_citizenId].walletAddress,\n            msg.sender\n        );\n    }\n\n    /**\n     * @dev Reactivate a citizen account (admin function)\n     * @param _citizenId Citizen ID to reactivate\n     */\n    function reactivateCitizen(uint256 _citizenId) external onlyOwner validCitizenId(_citizenId) {\n        citizens[_citizenId].isActive = true;\n        citizens[_citizenId].lastUpdateTimestamp = block.timestamp;\n    }\n\n    // View functions\n    function getCitizen(uint256 _citizenId) external view validCitizenId(_citizenId) returns (CitizenProfile memory) {\n        return citizens[_citizenId];\n    }\n\n    function getCitizenByWallet(address _wallet) external view returns (CitizenProfile memory) {\n        uint256 citizenId = walletToCitizenId[_wallet];\n        require(citizenId != 0, \"CitizenRegistry: Wallet not registered\");\n        return citizens[citizenId];\n    }\n\n    function getCitizenByENS(string memory _ensName) external view returns (CitizenProfile memory) {\n        uint256 citizenId = ensNameToCitizenId[_ensName];\n        require(citizenId != 0, \"CitizenRegistry: ENS name not registered\");\n        return citizens[citizenId];\n    }\n\n    function isCitizenRegistered(address _wallet) external view returns (bool) {\n        return walletToCitizenId[_wallet] != 0 && citizens[walletToCitizenId[_wallet]].isActive;\n    }\n\n    function getTotalCitizens() external view returns (uint256) {\n        return _citizenIdCounter;\n    }\n\n    function getVerificationLevel(address _wallet) external view returns (VerificationLevel) {\n        uint256 citizenId = walletToCitizenId[_wallet];\n        require(citizenId != 0, \"CitizenRegistry: Wallet not registered\");\n        return citizens[citizenId].verificationLevel;\n    }\n\n    function isENSNameAvailable(string memory _ensName) external view returns (bool) {\n        return !registeredEnsNames[_ensName];\n    }\n\n    // Internal functions\n    function _determineVerificationLevel(uint256 _followers, uint256 _following) internal pure returns (VerificationLevel) {\n        if (_followers == 0 && _following == 0) {\n            return VerificationLevel.UNVERIFIED;\n        } else if (_followers < 50) {\n            return VerificationLevel.BASIC;\n        } else {\n            return VerificationLevel.VERIFIED;\n        }\n    }\n\n    // Batch operations for efficiency\n    function getCitizensBatch(uint256[] memory _citizenIds) \n        external \n        view \n        returns (CitizenProfile[] memory) \n    {\n        CitizenProfile[] memory profiles = new CitizenProfile[](_citizenIds.length);\n        for (uint256 i = 0; i < _citizenIds.length; i++) {\n            if (_citizenIds[i] > 0 && _citizenIds[i] <= _citizenIdCounter) {\n                profiles[i] = citizens[_citizenIds[i]];\n            }\n        }\n        return profiles;\n    }\n\n    function getActiveCitizensCount() external view returns (uint256) {\n        uint256 activeCount = 0;\n        for (uint256 i = 1; i <= _citizenIdCounter; i++) {\n            if (citizens[i].isActive) {\n                activeCount++;\n            }\n        }\n        return activeCount;\n    }\n}"
    },
    "contracts/GovernmentProjectRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./CitizenIdentityRegistry.sol\";\n\n/**\n * @title GovernmentProjectRegistry\n * @dev Manages all government projects and their lifecycle\n * @author CitiProof Team\n */\ncontract GovernmentProjectRegistry is Ownable, ReentrancyGuard {\n    \n    CitizenIdentityRegistry public immutable citizenRegistry;\n    \n    // Project status enumeration\n    enum ProjectStatus {\n        PROPOSED,      // Project proposed but not approved\n        APPROVED,      // Project approved and funded\n        IN_PROGRESS,   // Project execution started\n        COMPLETED,     // Project completed successfully\n        CANCELLED,     // Project cancelled\n        UNDER_REVIEW   // Project under audit/review\n    }\n    \n    // Project category enumeration\n    enum ProjectCategory {\n        INFRASTRUCTURE,\n        HEALTHCARE,\n        EDUCATION,\n        ENVIRONMENT,\n        SOCIAL_SERVICES,\n        TECHNOLOGY,\n        SECURITY,\n        ECONOMIC_DEVELOPMENT,\n        OTHER\n    }\n    \n    // Project milestone structure\n    struct ProjectMilestone {\n        uint256 milestoneId;\n        string title;\n        string description;\n        uint256 targetDate;\n        uint256 completionDate;\n        uint256 budgetAllocated;\n        uint256 budgetSpent;\n        bool isCompleted;\n        string evidenceHash; // IPFS hash of completion evidence\n    }\n    \n    // Main project structure\n    struct Project {\n        uint256 projectId;\n        string title;\n        string description;\n        ProjectCategory category;\n        ProjectStatus status;\n        address governmentEntity; // Government wallet that created the project\n        uint256 totalBudget;\n        uint256 budgetSpent;\n        uint256 startDate;\n        uint256 estimatedEndDate;\n        uint256 actualEndDate;\n        string documentationHash; // IPFS hash for project documents\n        uint256 citizenSupportScore; // Based on citizen votes/feedback\n        bool isPublic; // Whether project details are public\n        uint256 creationTimestamp;\n        uint256 lastUpdateTimestamp;\n    }\n    \n    // Storage\n    uint256 private _projectIdCounter;\n    mapping(uint256 => Project) public projects;\n    mapping(uint256 => ProjectMilestone[]) public projectMilestones;\n    mapping(uint256 => mapping(uint256 => bool)) public milestoneCompleted; // projectId => milestoneId => completed\n    mapping(address => bool) public authorizedGovernmentEntities;\n    mapping(uint256 => uint256[]) public categoryProjects; // category => projectIds\n    mapping(address => uint256[]) public governmentEntityProjects; // entity => projectIds\n    \n    // Events\n    event ProjectCreated(\n        uint256 indexed projectId,\n        string title,\n        ProjectCategory category,\n        address indexed governmentEntity,\n        uint256 totalBudget\n    );\n    \n    event ProjectStatusUpdated(\n        uint256 indexed projectId,\n        ProjectStatus oldStatus,\n        ProjectStatus newStatus,\n        address indexed updatedBy\n    );\n    \n    event ProjectMilestoneAdded(\n        uint256 indexed projectId,\n        uint256 milestoneId,\n        string title,\n        uint256 targetDate,\n        uint256 budgetAllocated\n    );\n    \n    event ProjectMilestoneCompleted(\n        uint256 indexed projectId,\n        uint256 milestoneId,\n        uint256 completionDate,\n        uint256 actualBudgetSpent,\n        string evidenceHash\n    );\n    \n    event ProjectBudgetUpdated(\n        uint256 indexed projectId,\n        uint256 previousBudget,\n        uint256 newBudget,\n        address indexed updatedBy\n    );\n    \n    event GovernmentEntityAuthorized(\n        address indexed entity,\n        bool authorized,\n        address indexed authorizedBy\n    );\n    \n    // Modifiers\n    modifier onlyAuthorizedGovernment() {\n        require(authorizedGovernmentEntities[msg.sender], \"ProjectRegistry: Not authorized government entity\");\n        _;\n    }\n    \n    modifier validProjectId(uint256 _projectId) {\n        require(_projectId > 0 && _projectId <= _projectIdCounter, \"ProjectRegistry: Invalid project ID\");\n        _;\n    }\n    \n    modifier onlyProjectOwner(uint256 _projectId) {\n        require(projects[_projectId].governmentEntity == msg.sender, \"ProjectRegistry: Not project owner\");\n        _;\n    }\n    \n    constructor(\n        address initialOwner,\n        address _citizenRegistry\n    ) Ownable(initialOwner) {\n        require(_citizenRegistry != address(0), \"ProjectRegistry: Invalid citizen registry\");\n        citizenRegistry = CitizenIdentityRegistry(_citizenRegistry);\n    }\n    \n    /**\n     * @dev Create a new government project\n     */\n    function createProject(\n        string memory _title,\n        string memory _description,\n        ProjectCategory _category,\n        uint256 _totalBudget,\n        uint256 _estimatedEndDate,\n        string memory _documentationHash,\n        bool _isPublic\n    ) external onlyAuthorizedGovernment nonReentrant {\n        require(bytes(_title).length > 0, \"ProjectRegistry: Title cannot be empty\");\n        require(_totalBudget > 0, \"ProjectRegistry: Budget must be greater than 0\");\n        require(_estimatedEndDate > block.timestamp, \"ProjectRegistry: End date must be in future\");\n        \n        _projectIdCounter++;\n        uint256 newProjectId = _projectIdCounter;\n        \n        projects[newProjectId] = Project({\n            projectId: newProjectId,\n            title: _title,\n            description: _description,\n            category: _category,\n            status: ProjectStatus.PROPOSED,\n            governmentEntity: msg.sender,\n            totalBudget: _totalBudget,\n            budgetSpent: 0,\n            startDate: 0, // Will be set when approved\n            estimatedEndDate: _estimatedEndDate,\n            actualEndDate: 0,\n            documentationHash: _documentationHash,\n            citizenSupportScore: 0,\n            isPublic: _isPublic,\n            creationTimestamp: block.timestamp,\n            lastUpdateTimestamp: block.timestamp\n        });\n        \n        // Add to category and entity mappings\n        categoryProjects[uint256(_category)].push(newProjectId);\n        governmentEntityProjects[msg.sender].push(newProjectId);\n        \n        emit ProjectCreated(newProjectId, _title, _category, msg.sender, _totalBudget);\n    }\n    \n    /**\n     * @dev Update project status\n     */\n    function updateProjectStatus(\n        uint256 _projectId,\n        ProjectStatus _newStatus\n    ) external validProjectId(_projectId) onlyProjectOwner(_projectId) {\n        Project storage project = projects[_projectId];\n        ProjectStatus oldStatus = project.status;\n        \n        require(oldStatus != _newStatus, \"ProjectRegistry: Status unchanged\");\n        require(_isValidStatusTransition(oldStatus, _newStatus), \"ProjectRegistry: Invalid status transition\");\n        \n        project.status = _newStatus;\n        project.lastUpdateTimestamp = block.timestamp;\n        \n        // Set start date when approved\n        if (_newStatus == ProjectStatus.APPROVED && project.startDate == 0) {\n            project.startDate = block.timestamp;\n        }\n        \n        // Set completion date when completed\n        if (_newStatus == ProjectStatus.COMPLETED && project.actualEndDate == 0) {\n            project.actualEndDate = block.timestamp;\n        }\n        \n        emit ProjectStatusUpdated(_projectId, oldStatus, _newStatus, msg.sender);\n    }\n    \n    /**\n     * @dev Add milestone to project\n     */\n    function addProjectMilestone(\n        uint256 _projectId,\n        string memory _title,\n        string memory _description,\n        uint256 _targetDate,\n        uint256 _budgetAllocated\n    ) external validProjectId(_projectId) onlyProjectOwner(_projectId) {\n        require(bytes(_title).length > 0, \"ProjectRegistry: Milestone title cannot be empty\");\n        require(_targetDate > block.timestamp, \"ProjectRegistry: Target date must be in future\");\n        require(_budgetAllocated > 0, \"ProjectRegistry: Budget must be greater than 0\");\n        \n        Project storage project = projects[_projectId];\n        require(project.status == ProjectStatus.APPROVED || project.status == ProjectStatus.IN_PROGRESS, \n                \"ProjectRegistry: Project must be approved or in progress\");\n        \n        uint256 milestoneId = projectMilestones[_projectId].length + 1;\n        \n        ProjectMilestone memory newMilestone = ProjectMilestone({\n            milestoneId: milestoneId,\n            title: _title,\n            description: _description,\n            targetDate: _targetDate,\n            completionDate: 0,\n            budgetAllocated: _budgetAllocated,\n            budgetSpent: 0,\n            isCompleted: false,\n            evidenceHash: \"\"\n        });\n        \n        projectMilestones[_projectId].push(newMilestone);\n        \n        emit ProjectMilestoneAdded(_projectId, milestoneId, _title, _targetDate, _budgetAllocated);\n    }\n    \n    /**\n     * @dev Complete project milestone\n     */\n    function completeProjectMilestone(\n        uint256 _projectId,\n        uint256 _milestoneId,\n        uint256 _actualBudgetSpent,\n        string memory _evidenceHash\n    ) external validProjectId(_projectId) onlyProjectOwner(_projectId) {\n        require(_milestoneId > 0 && _milestoneId <= projectMilestones[_projectId].length, \n                \"ProjectRegistry: Invalid milestone ID\");\n        require(!milestoneCompleted[_projectId][_milestoneId], \"ProjectRegistry: Milestone already completed\");\n        require(bytes(_evidenceHash).length > 0, \"ProjectRegistry: Evidence hash required\");\n        \n        ProjectMilestone storage milestone = projectMilestones[_projectId][_milestoneId - 1];\n        Project storage project = projects[_projectId];\n        \n        require(_actualBudgetSpent <= milestone.budgetAllocated, \"ProjectRegistry: Spent exceeds allocated budget\");\n        require(project.budgetSpent + _actualBudgetSpent <= project.totalBudget, \n                \"ProjectRegistry: Total spent would exceed project budget\");\n        \n        // Update milestone\n        milestone.isCompleted = true;\n        milestone.completionDate = block.timestamp;\n        milestone.budgetSpent = _actualBudgetSpent;\n        milestone.evidenceHash = _evidenceHash;\n        milestoneCompleted[_projectId][_milestoneId] = true;\n        \n        // Update project budget\n        project.budgetSpent += _actualBudgetSpent;\n        project.lastUpdateTimestamp = block.timestamp;\n        \n        // Update project status to in progress if not already\n        if (project.status == ProjectStatus.APPROVED) {\n            project.status = ProjectStatus.IN_PROGRESS;\n            emit ProjectStatusUpdated(_projectId, ProjectStatus.APPROVED, ProjectStatus.IN_PROGRESS, msg.sender);\n        }\n        \n        emit ProjectMilestoneCompleted(_projectId, _milestoneId, block.timestamp, _actualBudgetSpent, _evidenceHash);\n    }\n    \n    /**\n     * @dev Update project budget (owner or admin only)\n     */\n    function updateProjectBudget(\n        uint256 _projectId,\n        uint256 _newBudget\n    ) external validProjectId(_projectId) {\n        require(\n            msg.sender == projects[_projectId].governmentEntity || msg.sender == owner(),\n            \"ProjectRegistry: Not authorized to update budget\"\n        );\n        require(_newBudget > 0, \"ProjectRegistry: Budget must be greater than 0\");\n        \n        Project storage project = projects[_projectId];\n        require(_newBudget >= project.budgetSpent, \"ProjectRegistry: New budget less than already spent\");\n        \n        uint256 previousBudget = project.totalBudget;\n        project.totalBudget = _newBudget;\n        project.lastUpdateTimestamp = block.timestamp;\n        \n        emit ProjectBudgetUpdated(_projectId, previousBudget, _newBudget, msg.sender);\n    }\n    \n    /**\n     * @dev Update citizen support score (called by voting contract)\n     */\n    function updateCitizenSupportScore(\n        uint256 _projectId,\n        uint256 _supportScore\n    ) external validProjectId(_projectId) {\n        // TODO: Add access control for voting contract\n        // require(msg.sender == votingContract, \"ProjectRegistry: Only voting contract can update support\");\n        \n        projects[_projectId].citizenSupportScore = _supportScore;\n        projects[_projectId].lastUpdateTimestamp = block.timestamp;\n    }\n    \n    // View functions\n    function getProject(uint256 _projectId) external view validProjectId(_projectId) returns (Project memory) {\n        Project memory project = projects[_projectId];\n        require(project.isPublic || msg.sender == project.governmentEntity || msg.sender == owner(), \n                \"ProjectRegistry: Project is not public\");\n        return project;\n    }\n    \n    function getProjectMilestones(uint256 _projectId) external view validProjectId(_projectId) returns (ProjectMilestone[] memory) {\n        Project memory project = projects[_projectId];\n        require(project.isPublic || msg.sender == project.governmentEntity || msg.sender == owner(), \n                \"ProjectRegistry: Project is not public\");\n        return projectMilestones[_projectId];\n    }\n    \n    function getProjectsByCategory(ProjectCategory _category) external view returns (uint256[] memory) {\n        return categoryProjects[uint256(_category)];\n    }\n    \n    function getProjectsByGovernmentEntity(address _entity) external view returns (uint256[] memory) {\n        return governmentEntityProjects[_entity];\n    }\n    \n    function getProjectsByStatus(ProjectStatus _status) external view returns (uint256[] memory) {\n        uint256[] memory result = new uint256[](_projectIdCounter);\n        uint256 count = 0;\n        \n        for (uint256 i = 1; i <= _projectIdCounter; i++) {\n            if (projects[i].status == _status && (projects[i].isPublic || msg.sender == owner())) {\n                result[count] = i;\n                count++;\n            }\n        }\n        \n        // Resize array to actual count\n        uint256[] memory finalResult = new uint256[](count);\n        for (uint256 i = 0; i < count; i++) {\n            finalResult[i] = result[i];\n        }\n        \n        return finalResult;\n    }\n    \n    function getProjectStats() external view returns (\n        uint256 totalProjects,\n        uint256 approvedProjects,\n        uint256 inProgressProjects,\n        uint256 completedProjects,\n        uint256 totalBudgetAllocated,\n        uint256 totalBudgetSpent\n    ) {\n        uint256 approved = 0;\n        uint256 inProgress = 0;\n        uint256 completed = 0;\n        uint256 totalAllocated = 0;\n        uint256 totalSpent = 0;\n        \n        for (uint256 i = 1; i <= _projectIdCounter; i++) {\n            Project storage project = projects[i];\n            \n            if (project.status == ProjectStatus.APPROVED) approved++;\n            else if (project.status == ProjectStatus.IN_PROGRESS) inProgress++;\n            else if (project.status == ProjectStatus.COMPLETED) completed++;\n            \n            totalAllocated += project.totalBudget;\n            totalSpent += project.budgetSpent;\n        }\n        \n        return (_projectIdCounter, approved, inProgress, completed, totalAllocated, totalSpent);\n    }\n    \n    function getTotalProjects() external view returns (uint256) {\n        return _projectIdCounter;\n    }\n    \n    function getProjectProgress(uint256 _projectId) external view validProjectId(_projectId) returns (\n        uint256 totalMilestones,\n        uint256 completedMilestones,\n        uint256 budgetUtilization // percentage in basis points (10000 = 100%)\n    ) {\n        Project memory project = projects[_projectId];\n        require(project.isPublic || msg.sender == project.governmentEntity || msg.sender == owner(), \n                \"ProjectRegistry: Project is not public\");\n        \n        ProjectMilestone[] memory milestones = projectMilestones[_projectId];\n        uint256 completed = 0;\n        \n        for (uint256 i = 0; i < milestones.length; i++) {\n            if (milestones[i].isCompleted) {\n                completed++;\n            }\n        }\n        \n        uint256 utilization = project.totalBudget > 0 ? \n                             (project.budgetSpent * 10000) / project.totalBudget : 0;\n        \n        return (milestones.length, completed, utilization);\n    }\n    \n    // Internal functions\n    function _isValidStatusTransition(ProjectStatus _from, ProjectStatus _to) internal pure returns (bool) {\n        if (_from == ProjectStatus.PROPOSED) {\n            return _to == ProjectStatus.APPROVED || _to == ProjectStatus.CANCELLED;\n        } else if (_from == ProjectStatus.APPROVED) {\n            return _to == ProjectStatus.IN_PROGRESS || _to == ProjectStatus.CANCELLED;\n        } else if (_from == ProjectStatus.IN_PROGRESS) {\n            return _to == ProjectStatus.COMPLETED || _to == ProjectStatus.UNDER_REVIEW || _to == ProjectStatus.CANCELLED;\n        } else if (_from == ProjectStatus.UNDER_REVIEW) {\n            return _to == ProjectStatus.COMPLETED || _to == ProjectStatus.IN_PROGRESS;\n        }\n        return false; // COMPLETED and CANCELLED are final states\n    }\n    \n    // Admin functions\n    function authorizeGovernmentEntity(address _entity, bool _authorized) external onlyOwner {\n        require(_entity != address(0), \"ProjectRegistry: Invalid entity address\");\n        authorizedGovernmentEntities[_entity] = _authorized;\n        emit GovernmentEntityAuthorized(_entity, _authorized, msg.sender);\n    }\n    \n    function emergencyUpdateProject(\n        uint256 _projectId,\n        ProjectStatus _status,\n        uint256 _newBudget\n    ) external onlyOwner validProjectId(_projectId) {\n        Project storage project = projects[_projectId];\n        ProjectStatus oldStatus = project.status;\n        \n        if (_status != oldStatus) {\n            project.status = _status;\n            emit ProjectStatusUpdated(_projectId, oldStatus, _status, msg.sender);\n        }\n        \n        if (_newBudget != project.totalBudget && _newBudget >= project.budgetSpent) {\n            uint256 previousBudget = project.totalBudget;\n            project.totalBudget = _newBudget;\n            emit ProjectBudgetUpdated(_projectId, previousBudget, _newBudget, msg.sender);\n        }\n        \n        project.lastUpdateTimestamp = block.timestamp;\n    }\n    \n    function setProjectPublic(uint256 _projectId, bool _isPublic) external onlyOwner validProjectId(_projectId) {\n        projects[_projectId].isPublic = _isPublic;\n        projects[_projectId].lastUpdateTimestamp = block.timestamp;\n    }\n}"
    },
    "contracts/IssueReportingSystem.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./CitizenIdentityRegistry.sol\";\nimport \"./ReputationSystem.sol\";\n\n/**\n * @title IssueReportingSystem\n * @dev Manages citizen-submitted reports and verification process\n * @author CitiProof Team\n */\ncontract IssueReportingSystem is Ownable, ReentrancyGuard {\n    \n    CitizenIdentityRegistry public immutable citizenRegistry;\n    ReputationSystem public reputationSystem;\n    \n    // Issue severity levels\n    enum IssueSeverity {\n        LOW,        // Minor issues, cosmetic problems\n        MEDIUM,     // Moderate impact on community\n        HIGH,       // Significant impact, urgent attention needed\n        CRITICAL    // Emergency, immediate action required\n    }\n    \n    // Issue status tracking\n    enum IssueStatus {\n        SUBMITTED,      // Newly submitted by citizen\n        UNDER_REVIEW,   // Being reviewed by authorities\n        VERIFIED,       // Confirmed as legitimate issue\n        IN_PROGRESS,    // Work started to address the issue\n        RESOLVED,       // Issue has been addressed\n        REJECTED,       // Issue deemed invalid/false\n        DUPLICATE       // Duplicate of existing issue\n    }\n    \n    // Issue categories\n    enum IssueCategory {\n        INFRASTRUCTURE,     // Roads, bridges, utilities\n        PUBLIC_SAFETY,      // Crime, dangerous conditions\n        ENVIRONMENT,        // Pollution, waste management\n        CORRUPTION,         // Government misconduct, fraud\n        SERVICE_QUALITY,    // Poor government services\n        BUDGET_MISUSE,      // Improper use of public funds\n        TRANSPARENCY,       // Lack of information disclosure\n        OTHER\n    }\n    \n    // Evidence structure\n    struct Evidence {\n        string evidenceHash; // IPFS hash\n        string ipfsDescriptionHash; // IPFS hash for evidence description\n        uint256 timestamp;\n        address submittedBy;\n        bool isVerified;\n    }\n    \n    // Issue report structure\n    struct IssueReport {\n        uint256 reportId;\n        uint256 citizenId;\n        address reporter;\n        string title; // Keep on-chain for indexing\n        string ipfsDescriptionHash; // IPFS hash for detailed description\n        IssueCategory category;\n        IssueSeverity severity;\n        IssueStatus status;\n        string ipfsLocationDataHash; // IPFS hash for location details\n        uint256 submitTimestamp;\n        uint256 lastUpdateTimestamp;\n        uint256 verificationScore; // Weighted verification score\n        uint256 supportCount; // Number of citizens supporting this report\n        address assignedTo; // Government entity assigned to handle\n        string ipfsResolutionNotesHash; // IPFS hash for resolution details\n        uint256 resolutionTimestamp;\n        bool isAnonymous;\n        uint256 duplicateOfReportId; // If marked as duplicate\n        string[] tags; // Searchable tags (keep on-chain for filtering)\n    }\n    \n    // Verification vote structure\n    struct VerificationVote {\n        uint256 citizenId;\n        address voter;\n        bool isSupporting; // true = supports report validity, false = disputes\n        string ipfsCommentsHash; // IPFS hash for detailed comments\n        uint256 timestamp;\n        uint256 voterReputationAtTime; // Voter's reputation when vote was cast\n    }\n    \n    // Storage\n    uint256 private _reportIdCounter;\n    mapping(uint256 => IssueReport) public reports;\n    mapping(uint256 => Evidence[]) public reportEvidence; // reportId => Evidence[]\n    mapping(uint256 => VerificationVote[]) public reportVerifications; // reportId => VerificationVote[]\n    mapping(uint256 => mapping(uint256 => bool)) public hasVotedOnReport; // reportId => citizenId => voted\n    mapping(uint256 => mapping(uint256 => bool)) public hasSupportedReport; // reportId => citizenId => supported\n    mapping(address => bool) public authorizedGovernmentEntities;\n    mapping(uint256 => uint256[]) public categoryReports; // category => reportIds\n    mapping(address => uint256[]) public citizenReports; // citizen address => reportIds\n    mapping(bytes32 => uint256[]) public locationReports; // location hash => reportIds\n    \n    // Configuration\n    uint256 public minimumVerificationScore = 100; // Minimum score to mark as verified\n    uint256 public verificationThreshold = 3; // Minimum verification votes needed\n    uint256 public duplicateThreshold = 80; // Similarity threshold for duplicates (in percentage)\n    \n    // Events\n    event IssueReported(\n        uint256 indexed reportId,\n        uint256 indexed citizenId,\n        address indexed reporter,\n        IssueCategory category,\n        IssueSeverity severity\n    );\n    \n    event IssueStatusUpdated(\n        uint256 indexed reportId,\n        IssueStatus previousStatus,\n        IssueStatus newStatus,\n        address indexed updatedBy\n    );\n    \n    event IssueVerificationVote(\n        uint256 indexed reportId,\n        uint256 indexed citizenId,\n        address indexed voter,\n        bool isSupporting,\n        uint256 voterReputation\n    );\n    \n    event EvidenceAdded(\n        uint256 indexed reportId,\n        string evidenceHash,\n        address indexed submittedBy\n    );\n    \n    event IssueAssigned(\n        uint256 indexed reportId,\n        address indexed assignedTo,\n        address indexed assignedBy\n    );\n    \n    event IssueResolved(\n        uint256 indexed reportId,\n        address indexed resolvedBy,\n        string resolutionNotes\n    );\n    \n    event IssueDuplicate(\n        uint256 indexed reportId,\n        uint256 indexed duplicateOfReportId,\n        address indexed markedBy\n    );\n    \n    // Modifiers\n    modifier onlyRegisteredCitizen() {\n        require(citizenRegistry.isCitizenRegistered(msg.sender), \n                \"IssueReporting: Must be registered citizen\");\n        _;\n    }\n    \n    modifier onlyAuthorizedGovernment() {\n        require(authorizedGovernmentEntities[msg.sender], \n                \"IssueReporting: Not authorized government entity\");\n        _;\n    }\n    \n    modifier validReportId(uint256 _reportId) {\n        require(_reportId > 0 && _reportId <= _reportIdCounter, \n                \"IssueReporting: Invalid report ID\");\n        _;\n    }\n    \n    modifier onlyReportOwnerOrGov(uint256 _reportId) {\n        require(\n            reports[_reportId].reporter == msg.sender || \n            authorizedGovernmentEntities[msg.sender] || \n            msg.sender == owner(),\n            \"IssueReporting: Not authorized to modify this report\"\n        );\n        _;\n    }\n    \n    constructor(\n        address initialOwner,\n        address _citizenRegistry,\n        address _reputationSystem\n    ) Ownable(initialOwner) {\n        require(_citizenRegistry != address(0), \"IssueReporting: Invalid citizen registry\");\n        require(_reputationSystem != address(0), \"IssueReporting: Invalid reputation system\");\n        \n        citizenRegistry = CitizenIdentityRegistry(_citizenRegistry);\n        reputationSystem = ReputationSystem(_reputationSystem);\n    }\n    \n    /**\n     * @dev Submit a new issue report\n     */\n    function submitIssueReport(\n        string memory _title,\n        string memory _ipfsDescriptionHash,\n        IssueCategory _category,\n        IssueSeverity _severity,\n        string memory _ipfsLocationDataHash,\n        string memory _evidenceHash,\n        string[] memory _tags,\n        bool _isAnonymous\n    ) external onlyRegisteredCitizen nonReentrant {\n        require(bytes(_title).length > 0, \"IssueReporting: Title cannot be empty\");\n        require(bytes(_ipfsDescriptionHash).length > 0, \"IssueReporting: IPFS description hash required\");\n        require(_tags.length <= 10, \"IssueReporting: Too many tags\");\n        \n        // Get citizen ID - using try/catch for safety\n        uint256 citizenId = 0;\n        try citizenRegistry.getCitizenByWallet(msg.sender) returns (CitizenIdentityRegistry.CitizenProfile memory profile) {\n            citizenId = profile.citizenId;\n        } catch {\n            revert(\"IssueReporting: Failed to get citizen ID\");\n        }\n        \n        _reportIdCounter++;\n        uint256 newReportId = _reportIdCounter;\n        \n        // Create report\n        reports[newReportId] = IssueReport({\n            reportId: newReportId,\n            citizenId: citizenId,\n            reporter: _isAnonymous ? address(0) : msg.sender,\n            title: _title,\n            ipfsDescriptionHash: _ipfsDescriptionHash,\n            category: _category,\n            severity: _severity,\n            status: IssueStatus.SUBMITTED,\n            ipfsLocationDataHash: _ipfsLocationDataHash,\n            submitTimestamp: block.timestamp,\n            lastUpdateTimestamp: block.timestamp,\n            verificationScore: 0,\n            supportCount: 0,\n            assignedTo: address(0),\n            ipfsResolutionNotesHash: \"\",\n            resolutionTimestamp: 0,\n            isAnonymous: _isAnonymous,\n            duplicateOfReportId: 0,\n            tags: _tags\n        });\n        \n        // Add to mappings\n        categoryReports[uint256(_category)].push(newReportId);\n        if (!_isAnonymous) {\n            citizenReports[msg.sender].push(newReportId);\n        }\n        \n        // Add location to mapping if provided\n        if (bytes(_ipfsLocationDataHash).length > 0) {\n            bytes32 locationHash = keccak256(abi.encodePacked(_ipfsLocationDataHash));\n            locationReports[locationHash].push(newReportId);\n        }\n        \n        // Add evidence if provided\n        if (bytes(_evidenceHash).length > 0) {\n            reportEvidence[newReportId].push(Evidence({\n                evidenceHash: _evidenceHash,\n                ipfsDescriptionHash: \"\", // Can be added later\n                timestamp: block.timestamp,\n                submittedBy: msg.sender,\n                isVerified: false\n            }));\n            \n            emit EvidenceAdded(newReportId, _evidenceHash, msg.sender);\n        }\n        \n        emit IssueReported(newReportId, citizenId, _isAnonymous ? address(0) : msg.sender, _category, _severity);\n    }\n    \n    /**\n     * @dev Add evidence to existing report\n     */\n    function addEvidence(\n        uint256 _reportId,\n        string memory _evidenceHash,\n        string memory _ipfsDescriptionHash\n    ) external onlyRegisteredCitizen validReportId(_reportId) {\n        require(bytes(_evidenceHash).length > 0, \"IssueReporting: Evidence hash cannot be empty\");\n        require(bytes(_ipfsDescriptionHash).length > 0, \"IssueReporting: IPFS description hash required\");\n        \n        IssueReport storage report = reports[_reportId];\n        require(report.status != IssueStatus.RESOLVED && report.status != IssueStatus.REJECTED, \n                \"IssueReporting: Cannot add evidence to closed report\");\n        \n        reportEvidence[_reportId].push(Evidence({\n            evidenceHash: _evidenceHash,\n            ipfsDescriptionHash: _ipfsDescriptionHash,\n            timestamp: block.timestamp,\n            submittedBy: msg.sender,\n            isVerified: false\n        }));\n        \n        report.lastUpdateTimestamp = block.timestamp;\n        \n        emit EvidenceAdded(_reportId, _evidenceHash, msg.sender);\n    }\n    \n    /**\n     * @dev Vote to verify/support an issue report\n     */\n    function verifyReport(\n        uint256 _reportId,\n        bool _isSupporting,\n        string memory _ipfsCommentsHash\n    ) external onlyRegisteredCitizen validReportId(_reportId) {\n        // Get citizen ID - using try/catch for safety\n        uint256 citizenId = 0;\n        try citizenRegistry.getCitizenByWallet(msg.sender) returns (CitizenIdentityRegistry.CitizenProfile memory profile) {\n            citizenId = profile.citizenId;\n        } catch {\n            revert(\"IssueReporting: Failed to get citizen ID\");\n        }\n        require(!hasVotedOnReport[_reportId][citizenId], \"IssueReporting: Already voted on this report\");\n        require(reports[_reportId].citizenId != citizenId, \"IssueReporting: Cannot vote on own report\");\n        \n        IssueReport storage report = reports[_reportId];\n        require(report.status == IssueStatus.SUBMITTED || report.status == IssueStatus.UNDER_REVIEW, \n                \"IssueReporting: Report not open for verification\");\n        \n        // Get voter's current reputation score\n        uint256 voterReputation = 100; // Default reputation\n        try reputationSystem.getReputationScore(citizenId) returns (uint256 reputation) {\n            voterReputation = reputation;\n        } catch {}\n        \n        // Record verification vote\n        reportVerifications[_reportId].push(VerificationVote({\n            citizenId: citizenId,\n            voter: msg.sender,\n            isSupporting: _isSupporting,\n            ipfsCommentsHash: _ipfsCommentsHash,\n            timestamp: block.timestamp,\n            voterReputationAtTime: voterReputation\n        }));\n        \n        hasVotedOnReport[_reportId][citizenId] = true;\n        \n        // Update verification score (weighted by reputation)\n        uint256 voteWeight = _calculateVoteWeight(voterReputation);\n        if (_isSupporting) {\n            report.verificationScore += voteWeight;\n            report.supportCount++;\n        } else {\n            // Negative votes reduce the score\n            if (report.verificationScore >= voteWeight) {\n                report.verificationScore -= voteWeight;\n            } else {\n                report.verificationScore = 0;\n            }\n        }\n        \n        report.lastUpdateTimestamp = block.timestamp;\n        \n        // Auto-verify if thresholds are met\n        if (report.verificationScore >= minimumVerificationScore && \n            reportVerifications[_reportId].length >= verificationThreshold &&\n            report.status == IssueStatus.SUBMITTED) {\n            \n            report.status = IssueStatus.VERIFIED;\n            emit IssueStatusUpdated(_reportId, IssueStatus.SUBMITTED, IssueStatus.VERIFIED, address(this));\n            \n            // Award reputation to reporter if verified\n            bytes32 reportHash = keccak256(abi.encodePacked(\"report\", _reportId));\n            try reputationSystem.addIssueReportReputation(report.citizenId, reportHash) {} catch {}\n        }\n        \n        emit IssueVerificationVote(_reportId, citizenId, msg.sender, _isSupporting, voterReputation);\n    }\n    \n    /**\n     * @dev Update issue status (government entities only)\n     */\n    function updateIssueStatus(\n        uint256 _reportId,\n        IssueStatus _newStatus,\n        string memory _ipfsNotesHash\n    ) external onlyAuthorizedGovernment validReportId(_reportId) {\n        IssueReport storage report = reports[_reportId];\n        IssueStatus previousStatus = report.status;\n        \n        require(previousStatus != _newStatus, \"IssueReporting: Status unchanged\");\n        require(_isValidStatusTransition(previousStatus, _newStatus), \n                \"IssueReporting: Invalid status transition\");\n        \n        report.status = _newStatus;\n        report.lastUpdateTimestamp = block.timestamp;\n        \n        // Handle resolution\n        if (_newStatus == IssueStatus.RESOLVED) {\n            report.ipfsResolutionNotesHash = _ipfsNotesHash;\n            report.resolutionTimestamp = block.timestamp;\n        }\n        \n        // Handle assignment\n        if (_newStatus == IssueStatus.IN_PROGRESS && report.assignedTo == address(0)) {\n            report.assignedTo = msg.sender;\n            emit IssueAssigned(_reportId, msg.sender, msg.sender);\n        }\n        \n        // Penalize false reports\n        if (_newStatus == IssueStatus.REJECTED && report.citizenId != 0) {\n            bytes32 reportHash = keccak256(abi.encodePacked(\"false_report\", _reportId));\n            try reputationSystem.penalizeFalseReport(report.citizenId, reportHash) {} catch {}\n        }\n        \n        emit IssueStatusUpdated(_reportId, previousStatus, _newStatus, msg.sender);\n        \n        if (_newStatus == IssueStatus.RESOLVED) {\n            emit IssueResolved(_reportId, msg.sender, _ipfsNotesHash);\n        }\n    }\n    \n    /**\n     * @dev Assign issue to government entity\n     */\n    function assignIssue(\n        uint256 _reportId,\n        address _assignee\n    ) external onlyAuthorizedGovernment validReportId(_reportId) {\n        require(authorizedGovernmentEntities[_assignee], \"IssueReporting: Assignee not authorized\");\n        \n        IssueReport storage report = reports[_reportId];\n        require(report.status == IssueStatus.VERIFIED || report.status == IssueStatus.UNDER_REVIEW, \n                \"IssueReporting: Report must be verified or under review\");\n        \n        report.assignedTo = _assignee;\n        report.lastUpdateTimestamp = block.timestamp;\n        \n        emit IssueAssigned(_reportId, _assignee, msg.sender);\n    }\n    \n    /**\n     * @dev Mark report as duplicate\n     */\n    function markAsDuplicate(\n        uint256 _reportId,\n        uint256 _originalReportId\n    ) external onlyAuthorizedGovernment validReportId(_reportId) validReportId(_originalReportId) {\n        require(_reportId != _originalReportId, \"IssueReporting: Cannot mark as duplicate of itself\");\n        require(reports[_originalReportId].status != IssueStatus.REJECTED, \n                \"IssueReporting: Original report is rejected\");\n        \n        IssueReport storage report = reports[_reportId];\n        IssueStatus previousStatus = report.status;\n        \n        report.status = IssueStatus.DUPLICATE;\n        report.duplicateOfReportId = _originalReportId;\n        report.lastUpdateTimestamp = block.timestamp;\n        \n        // Increase support count for original report\n        reports[_originalReportId].supportCount++;\n        \n        emit IssueStatusUpdated(_reportId, previousStatus, IssueStatus.DUPLICATE, msg.sender);\n        emit IssueDuplicate(_reportId, _originalReportId, msg.sender);\n    }\n    \n    // View functions\n    function getReport(uint256 _reportId) external view validReportId(_reportId) returns (IssueReport memory) {\n        return reports[_reportId];\n    }\n    \n    function getReportEvidence(uint256 _reportId) external view validReportId(_reportId) returns (Evidence[] memory) {\n        return reportEvidence[_reportId];\n    }\n    \n    function getReportVerifications(uint256 _reportId) external view validReportId(_reportId) returns (VerificationVote[] memory) {\n        return reportVerifications[_reportId];\n    }\n    \n    function getReportsByCategory(IssueCategory _category) external view returns (uint256[] memory) {\n        return categoryReports[uint256(_category)];\n    }\n    \n    function getCitizenReports(address _citizen) external view returns (uint256[] memory) {\n        return citizenReports[_citizen];\n    }\n    \n    function getReportsByStatus(IssueStatus _status) external view returns (uint256[] memory) {\n        uint256 count = 0;\n        \n        // Count reports with status\n        for (uint256 i = 1; i <= _reportIdCounter; i++) {\n            if (reports[i].status == _status) {\n                count++;\n            }\n        }\n        \n        // Create result array\n        uint256[] memory result = new uint256[](count);\n        uint256 index = 0;\n        \n        for (uint256 i = 1; i <= _reportIdCounter; i++) {\n            if (reports[i].status == _status) {\n                result[index] = i;\n                index++;\n            }\n        }\n        \n        return result;\n    }\n    \n    function getReportStats() external view returns (\n        uint256 totalReports,\n        uint256 verifiedReports,\n        uint256 resolvedReports,\n        uint256 pendingReports\n    ) {\n        uint256 verified = 0;\n        uint256 resolved = 0;\n        uint256 pending = 0;\n        \n        for (uint256 i = 1; i <= _reportIdCounter; i++) {\n            IssueStatus status = reports[i].status;\n            \n            if (status == IssueStatus.VERIFIED) verified++;\n            else if (status == IssueStatus.RESOLVED) resolved++;\n            else if (status == IssueStatus.SUBMITTED || status == IssueStatus.UNDER_REVIEW || status == IssueStatus.IN_PROGRESS) {\n                pending++;\n            }\n        }\n        \n        return (_reportIdCounter, verified, resolved, pending);\n    }\n    \n    function getTotalReports() external view returns (uint256) {\n        return _reportIdCounter;\n    }\n    \n    // Internal functions\n    function _calculateVoteWeight(uint256 _reputation) internal pure returns (uint256) {\n        // Base weight of 10, with bonus based on reputation\n        // Higher reputation citizens have more influence\n        if (_reputation >= 1000) return 50;      // High reputation\n        else if (_reputation >= 500) return 30; // Medium reputation\n        else if (_reputation >= 100) return 20; // Basic reputation\n        else return 10;                          // New/low reputation\n    }\n    \n    function _isValidStatusTransition(IssueStatus _from, IssueStatus _to) internal pure returns (bool) {\n        if (_from == IssueStatus.SUBMITTED) {\n            return _to == IssueStatus.UNDER_REVIEW || _to == IssueStatus.VERIFIED || \n                   _to == IssueStatus.REJECTED || _to == IssueStatus.DUPLICATE;\n        } else if (_from == IssueStatus.UNDER_REVIEW) {\n            return _to == IssueStatus.VERIFIED || _to == IssueStatus.REJECTED || \n                   _to == IssueStatus.DUPLICATE || _to == IssueStatus.IN_PROGRESS;\n        } else if (_from == IssueStatus.VERIFIED) {\n            return _to == IssueStatus.IN_PROGRESS || _to == IssueStatus.REJECTED;\n        } else if (_from == IssueStatus.IN_PROGRESS) {\n            return _to == IssueStatus.RESOLVED || _to == IssueStatus.UNDER_REVIEW;\n        }\n        return false; // RESOLVED, REJECTED, DUPLICATE are final states\n    }\n    \n    // Admin functions\n    function authorizeGovernmentEntity(address _entity, bool _authorized) external onlyOwner {\n        require(_entity != address(0), \"IssueReporting: Invalid entity address\");\n        authorizedGovernmentEntities[_entity] = _authorized;\n    }\n    \n    function updateVerificationThresholds(\n        uint256 _minimumScore,\n        uint256 _verificationThreshold\n    ) external onlyOwner {\n        require(_minimumScore > 0, \"IssueReporting: Minimum score must be positive\");\n        require(_verificationThreshold > 0, \"IssueReporting: Verification threshold must be positive\");\n        \n        minimumVerificationScore = _minimumScore;\n        verificationThreshold = _verificationThreshold;\n    }\n    \n    function updateReputationSystem(address _reputationSystem) external onlyOwner {\n        require(_reputationSystem != address(0), \"IssueReporting: Invalid reputation system\");\n        reputationSystem = ReputationSystem(_reputationSystem);\n    }\n    \n    function emergencyUpdateReportStatus(\n        uint256 _reportId,\n        IssueStatus _status\n    ) external onlyOwner validReportId(_reportId) {\n        IssueStatus previousStatus = reports[_reportId].status;\n        reports[_reportId].status = _status;\n        reports[_reportId].lastUpdateTimestamp = block.timestamp;\n        \n        emit IssueStatusUpdated(_reportId, previousStatus, _status, msg.sender);\n    }\n}"
    },
    "contracts/ReputationSystem.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./CitizenIdentityRegistry.sol\";\n\n/**\n * @title ReputationSystem\n * @dev Manages citizen reputation scores based on verified activities\n * @author CitiProof Team\n */\ncontract ReputationSystem is Ownable, ReentrancyGuard {\n    \n    // Reference to CitizenIdentityRegistry\n    CitizenIdentityRegistry public immutable citizenRegistry;\n\n    // Reputation scoring configuration\n    struct ReputationConfig {\n        uint256 issueReportReward;      // Points for verified issue reports\n        uint256 verificationReward;     // Points for successful verifications\n        uint256 votingReward;          // Points for participation in voting\n        uint256 projectCompletionReward; // Points for project milestone completion\n        uint256 falseReportPenalty;    // Penalty for false/spam reports\n        uint256 maxDailyEarnings;      // Max points per day to prevent gaming\n        uint256 decayRate;             // Daily reputation decay (in basis points)\n        uint256 minimumDecayThreshold; // Minimum reputation before decay applies\n    }\n\n    ReputationConfig public config;\n\n    // Reputation tracking\n    struct ReputationData {\n        uint256 totalScore;\n        uint256 lastUpdateTimestamp;\n        uint256 dailyEarnings;\n        uint256 lastEarningsReset;\n        mapping(bytes32 => bool) actionCompleted; // Prevent double rewards\n        uint256 totalReports;\n        uint256 verifiedReports;\n        uint256 totalVerifications;\n        uint256 successfulVerifications;\n        uint256 votingParticipation;\n    }\n\n    // Storage\n    mapping(uint256 => ReputationData) private reputationData; // citizenId => ReputationData\n    mapping(address => bool) public authorizedContracts; // Contracts allowed to update reputation\n\n    // Events\n    event ReputationUpdated(\n        uint256 indexed citizenId,\n        address indexed citizen,\n        uint256 oldScore,\n        uint256 newScore,\n        string reason\n    );\n\n    event ReputationConfigUpdated(\n        uint256 issueReportReward,\n        uint256 verificationReward,\n        uint256 votingReward,\n        uint256 projectCompletionReward\n    );\n\n    event ContractAuthorized(address indexed contractAddress, bool authorized);\n\n    // Modifiers\n    modifier onlyAuthorizedContract() {\n        require(authorizedContracts[msg.sender], \"ReputationSystem: Caller not authorized\");\n        _;\n    }\n\n    modifier validCitizenId(uint256 _citizenId) {\n        require(_citizenId > 0, \"ReputationSystem: Invalid citizen ID\");\n        // Additional validation by getting citizen profile\n        try citizenRegistry.getCitizen(_citizenId) returns (CitizenIdentityRegistry.CitizenProfile memory profile) {\n            require(profile.isActive, \"ReputationSystem: Citizen not active\");\n        } catch {\n            revert(\"ReputationSystem: Citizen does not exist\");\n        }\n        _;\n    }\n\n    constructor(\n        address initialOwner,\n        address _citizenRegistry\n    ) Ownable(initialOwner) {\n        require(_citizenRegistry != address(0), \"ReputationSystem: Invalid citizen registry address\");\n        citizenRegistry = CitizenIdentityRegistry(_citizenRegistry);\n\n        // Initialize default configuration\n        config = ReputationConfig({\n            issueReportReward: 50,        // 50 points per verified report\n            verificationReward: 25,       // 25 points per verification\n            votingReward: 10,            // 10 points per vote\n            projectCompletionReward: 100, // 100 points per project milestone\n            falseReportPenalty: 75,      // -75 points for false reports\n            maxDailyEarnings: 200,       // Max 200 points per day\n            decayRate: 10,               // 0.1% daily decay (10 basis points)\n            minimumDecayThreshold: 100   // No decay below 100 points\n        });\n    }\n\n    /**\n     * @dev Add reputation points for verified issue report\n     */\n    function addIssueReportReputation(uint256 _citizenId, bytes32 _reportId) \n        external \n        onlyAuthorizedContract \n        validCitizenId(_citizenId) \n    {\n        bytes32 actionId = keccak256(abi.encodePacked(\"issue_report\", _reportId));\n        require(!reputationData[_citizenId].actionCompleted[actionId], \n                \"ReputationSystem: Reward already claimed for this report\");\n\n        _addReputation(_citizenId, config.issueReportReward, \"Verified issue report\");\n        reputationData[_citizenId].actionCompleted[actionId] = true;\n        reputationData[_citizenId].totalReports++;\n        reputationData[_citizenId].verifiedReports++;\n    }\n\n    /**\n     * @dev Add reputation points for successful verification\n     */\n    function addVerificationReputation(uint256 _citizenId, bytes32 _verificationId) \n        external \n        onlyAuthorizedContract \n        validCitizenId(_citizenId) \n    {\n        bytes32 actionId = keccak256(abi.encodePacked(\"verification\", _verificationId));\n        require(!reputationData[_citizenId].actionCompleted[actionId], \n                \"ReputationSystem: Reward already claimed for this verification\");\n\n        _addReputation(_citizenId, config.verificationReward, \"Successful verification\");\n        reputationData[_citizenId].actionCompleted[actionId] = true;\n        reputationData[_citizenId].totalVerifications++;\n        reputationData[_citizenId].successfulVerifications++;\n    }\n\n    /**\n     * @dev Add reputation points for voting participation\n     */\n    function addVotingReputation(uint256 _citizenId, bytes32 _voteId) \n        external \n        onlyAuthorizedContract \n        validCitizenId(_citizenId) \n    {\n        bytes32 actionId = keccak256(abi.encodePacked(\"vote\", _voteId));\n        require(!reputationData[_citizenId].actionCompleted[actionId], \n                \"ReputationSystem: Reward already claimed for this vote\");\n\n        _addReputation(_citizenId, config.votingReward, \"Voting participation\");\n        reputationData[_citizenId].actionCompleted[actionId] = true;\n        reputationData[_citizenId].votingParticipation++;\n    }\n\n    /**\n     * @dev Add reputation points for project completion\n     */\n    function addProjectCompletionReputation(uint256 _citizenId, bytes32 _projectId) \n        external \n        onlyAuthorizedContract \n        validCitizenId(_citizenId) \n    {\n        bytes32 actionId = keccak256(abi.encodePacked(\"project\", _projectId));\n        require(!reputationData[_citizenId].actionCompleted[actionId], \n                \"ReputationSystem: Reward already claimed for this project\");\n\n        _addReputation(_citizenId, config.projectCompletionReward, \"Project milestone completion\");\n        reputationData[_citizenId].actionCompleted[actionId] = true;\n    }\n\n    /**\n     * @dev Penalize reputation for false reports\n     */\n    function penalizeFalseReport(uint256 _citizenId, bytes32 _reportId) \n        external \n        onlyAuthorizedContract \n        validCitizenId(_citizenId) \n    {\n        bytes32 actionId = keccak256(abi.encodePacked(\"false_report\", _reportId));\n        require(!reputationData[_citizenId].actionCompleted[actionId], \n                \"ReputationSystem: Penalty already applied for this report\");\n\n        _subtractReputation(_citizenId, config.falseReportPenalty, \"False report penalty\");\n        reputationData[_citizenId].actionCompleted[actionId] = true;\n        reputationData[_citizenId].totalReports++;\n        // Note: verifiedReports count remains unchanged\n    }\n\n    /**\n     * @dev Apply daily reputation decay to prevent inflation\n     */\n    function applyDailyDecay(uint256[] calldata _citizenIds) external {\n        for (uint256 i = 0; i < _citizenIds.length; i++) {\n            _applyDecay(_citizenIds[i]);\n        }\n    }\n\n    /**\n     * @dev Internal function to add reputation with daily limits\n     */\n    function _addReputation(uint256 _citizenId, uint256 _points, string memory _reason) internal {\n        ReputationData storage data = reputationData[_citizenId];\n        \n        // Reset daily earnings if it's a new day\n        if (block.timestamp > data.lastEarningsReset + 1 days) {\n            data.dailyEarnings = 0;\n            data.lastEarningsReset = block.timestamp;\n        }\n\n        // Check daily earning limits\n        uint256 actualPoints = _points;\n        if (data.dailyEarnings + _points > config.maxDailyEarnings) {\n            actualPoints = config.maxDailyEarnings > data.dailyEarnings ? \n                           config.maxDailyEarnings - data.dailyEarnings : 0;\n        }\n\n        if (actualPoints > 0) {\n            uint256 oldScore = data.totalScore;\n            data.totalScore += actualPoints;\n            data.dailyEarnings += actualPoints;\n            data.lastUpdateTimestamp = block.timestamp;\n\n            // Update citizen registry with new score\n            citizenRegistry.updateReputationScore(_citizenId, data.totalScore);\n\n            // Get citizen address from registry\n            address citizenAddress = address(0);\n            try citizenRegistry.getCitizen(_citizenId) returns (CitizenIdentityRegistry.CitizenProfile memory profile) {\n                citizenAddress = profile.walletAddress;\n            } catch {}\n            \n            emit ReputationUpdated(_citizenId, citizenAddress, oldScore, data.totalScore, _reason);\n        }\n    }\n\n    /**\n     * @dev Internal function to subtract reputation\n     */\n    function _subtractReputation(uint256 _citizenId, uint256 _points, string memory _reason) internal {\n        ReputationData storage data = reputationData[_citizenId];\n        uint256 oldScore = data.totalScore;\n        \n        // Ensure reputation doesn't go below 0\n        if (data.totalScore >= _points) {\n            data.totalScore -= _points;\n        } else {\n            data.totalScore = 0;\n        }\n        \n        data.lastUpdateTimestamp = block.timestamp;\n\n        // Update citizen registry with new score\n        citizenRegistry.updateReputationScore(_citizenId, data.totalScore);\n\n        // Get citizen address from registry\n        address citizenAddress = address(0);\n        try citizenRegistry.getCitizen(_citizenId) returns (CitizenIdentityRegistry.CitizenProfile memory profile) {\n            citizenAddress = profile.walletAddress;\n        } catch {}\n        emit ReputationUpdated(_citizenId, citizenAddress, oldScore, data.totalScore, _reason);\n    }\n\n    /**\n     * @dev Apply reputation decay for inactive users\n     */\n    function _applyDecay(uint256 _citizenId) internal validCitizenId(_citizenId) {\n        ReputationData storage data = reputationData[_citizenId];\n        \n        // Only apply decay if above minimum threshold and it's been at least a day\n        if (data.totalScore > config.minimumDecayThreshold && \n            block.timestamp > data.lastUpdateTimestamp + 1 days) {\n            \n            uint256 daysSinceUpdate = (block.timestamp - data.lastUpdateTimestamp) / 1 days;\n            uint256 decayAmount = (data.totalScore * config.decayRate * daysSinceUpdate) / 10000;\n            \n            if (decayAmount > 0) {\n                _subtractReputation(_citizenId, decayAmount, \"Daily reputation decay\");\n            }\n        }\n    }\n\n    // View functions\n    function getReputationScore(uint256 _citizenId) external view validCitizenId(_citizenId) returns (uint256) {\n        return reputationData[_citizenId].totalScore;\n    }\n\n    function getReputationStats(uint256 _citizenId) \n        external \n        view \n        validCitizenId(_citizenId) \n        returns (\n            uint256 totalScore,\n            uint256 totalReports,\n            uint256 verifiedReports,\n            uint256 totalVerifications,\n            uint256 successfulVerifications,\n            uint256 votingParticipation,\n            uint256 lastUpdateTimestamp\n        ) \n    {\n        ReputationData storage data = reputationData[_citizenId];\n        return (\n            data.totalScore,\n            data.totalReports,\n            data.verifiedReports,\n            data.totalVerifications,\n            data.successfulVerifications,\n            data.votingParticipation,\n            data.lastUpdateTimestamp\n        );\n    }\n\n    function getDailyEarningsInfo(uint256 _citizenId) \n        external \n        view \n        validCitizenId(_citizenId) \n        returns (uint256 dailyEarnings, uint256 remainingEarnings, uint256 lastReset) \n    {\n        ReputationData storage data = reputationData[_citizenId];\n        uint256 remaining = config.maxDailyEarnings > data.dailyEarnings ? \n                           config.maxDailyEarnings - data.dailyEarnings : 0;\n        \n        return (data.dailyEarnings, remaining, data.lastEarningsReset);\n    }\n\n    function getTopReputationCitizens(uint256 _limit) \n        external \n        view \n        returns (uint256[] memory citizenIds, uint256[] memory scores) \n    {\n        uint256 totalCitizens = citizenRegistry.getTotalCitizens();\n        if (_limit > totalCitizens) _limit = totalCitizens;\n        \n        citizenIds = new uint256[](_limit);\n        scores = new uint256[](_limit);\n        uint256 count = 0;\n        \n        // Simple implementation - collect first _limit active citizens with scores\n        for (uint256 i = 1; i <= totalCitizens && count < _limit; i++) {\n            try citizenRegistry.getCitizen(i) returns (CitizenIdentityRegistry.CitizenProfile memory profile) {\n                if (profile.isActive) {\n                    citizenIds[count] = i;\n                    scores[count] = reputationData[i].totalScore;\n                    count++;\n                }\n            } catch {\n                // Skip invalid citizens\n                continue;\n            }\n        }\n        \n        return (citizenIds, scores);\n    }\n\n    // Admin functions\n    function updateConfig(\n        uint256 _issueReportReward,\n        uint256 _verificationReward,\n        uint256 _votingReward,\n        uint256 _projectCompletionReward,\n        uint256 _falseReportPenalty,\n        uint256 _maxDailyEarnings,\n        uint256 _decayRate,\n        uint256 _minimumDecayThreshold\n    ) external onlyOwner {\n        config.issueReportReward = _issueReportReward;\n        config.verificationReward = _verificationReward;\n        config.votingReward = _votingReward;\n        config.projectCompletionReward = _projectCompletionReward;\n        config.falseReportPenalty = _falseReportPenalty;\n        config.maxDailyEarnings = _maxDailyEarnings;\n        config.decayRate = _decayRate;\n        config.minimumDecayThreshold = _minimumDecayThreshold;\n\n        emit ReputationConfigUpdated(\n            _issueReportReward,\n            _verificationReward,\n            _votingReward,\n            _projectCompletionReward\n        );\n    }\n\n    function authorizeContract(address _contract, bool _authorized) external onlyOwner {\n        require(_contract != address(0), \"ReputationSystem: Invalid contract address\");\n        authorizedContracts[_contract] = _authorized;\n        emit ContractAuthorized(_contract, _authorized);\n    }\n\n    function emergencyResetReputation(uint256 _citizenId, uint256 _newScore) external onlyOwner {\n        ReputationData storage data = reputationData[_citizenId];\n        uint256 oldScore = data.totalScore;\n        data.totalScore = _newScore;\n        data.lastUpdateTimestamp = block.timestamp;\n\n        citizenRegistry.updateReputationScore(_citizenId, _newScore);\n\n        // Get citizen address from registry\n        address citizenAddress = address(0);\n        try citizenRegistry.getCitizen(_citizenId) returns (CitizenIdentityRegistry.CitizenProfile memory profile) {\n            citizenAddress = profile.walletAddress;\n        } catch {}\n        emit ReputationUpdated(_citizenId, citizenAddress, oldScore, _newScore, \"Emergency reset\");\n    }\n}"
    },
    "contracts/TreasuryFundTracking.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./GovernmentProjectRegistry.sol\";\nimport \"./CitizenIdentityRegistry.sol\";\n\n/**\n * @title TreasuryFundTracking\n * @dev Handles all financial transparency and fund allocation tracking\n * @author CitiProof Team\n */\ncontract TreasuryFundTracking is Ownable, ReentrancyGuard {\n    \n    GovernmentProjectRegistry public immutable projectRegistry;\n    CitizenIdentityRegistry public immutable citizenRegistry;\n    \n    // Fund source enumeration\n    enum FundSource {\n        GOVERNMENT_BUDGET,\n        DONOR_CONTRIBUTION,\n        GRANTS,\n        FUNDRAISING,\n        OTHER\n    }\n    \n    // Transaction type enumeration\n    enum TransactionType {\n        ALLOCATION,    // Funds allocated to project\n        EXPENDITURE,   // Actual spending\n        REFUND,        // Funds returned\n        TRANSFER,      // Inter-project transfer\n        DONATION_IN,   // Donation received\n        WITHDRAWAL     // Emergency withdrawal\n    }\n    \n    // Fund allocation structure\n    struct FundAllocation {\n        uint256 allocationId;\n        uint256 projectId;\n        uint256 amount;\n        FundSource source;\n        address authorizedBy;\n        uint256 timestamp;\n        string ipfsDescriptionHash; // IPFS hash for detailed description\n        bool isActive;\n        string documentHash; // IPFS hash for supporting documents\n    }\n    \n    // Financial transaction structure\n    struct FinancialTransaction {\n        uint256 transactionId;\n        uint256 projectId;\n        uint256 amount;\n        TransactionType transactionType;\n        FundSource source;\n        address authorizedBy;\n        address recipient; // Can be contractor, vendor, etc.\n        uint256 timestamp;\n        string ipfsDescriptionHash; // IPFS hash for detailed description\n        string receiptHash; // IPFS hash for receipt/proof\n        bool isVerified;\n        address verifiedBy;\n        uint256 verificationTimestamp;\n    }\n    \n    // Donor contribution structure\n    struct DonorContribution {\n        uint256 contributionId;\n        address donor;\n        uint256 amount;\n        uint256 projectId; // 0 for general fund\n        uint256 timestamp;\n        string ipfsMessageHash; // IPFS hash for donation message\n        bool isAnonymous;\n        bool isRefunded;\n    }\n    \n    // Budget allocation structure\n    struct BudgetAllocation {\n        uint256 totalBudget;\n        uint256 allocatedBudget;\n        uint256 spentBudget;\n        uint256 availableBudget;\n        mapping(uint256 => uint256) projectAllocations; // projectId => allocated amount\n        mapping(uint256 => uint256) projectSpending;    // projectId => spent amount\n    }\n    \n    // Storage\n    uint256 private _allocationIdCounter;\n    uint256 private _transactionIdCounter;\n    uint256 private _contributionIdCounter;\n    \n    BudgetAllocation private budget;\n    mapping(uint256 => FundAllocation) public allocations;\n    mapping(uint256 => FinancialTransaction) public transactions;\n    mapping(uint256 => DonorContribution) public contributions;\n    mapping(uint256 => uint256[]) public projectAllocations; // projectId => allocationIds\n    mapping(uint256 => uint256[]) public projectTransactions; // projectId => transactionIds\n    mapping(address => uint256[]) public donorContributions; // donor => contributionIds\n    mapping(address => bool) public authorizedTreasurers;\n    \n    // Events\n    event FundsAllocated(\n        uint256 indexed allocationId,\n        uint256 indexed projectId,\n        uint256 amount,\n        FundSource source,\n        address indexed authorizedBy\n    );\n    \n    event TransactionRecorded(\n        uint256 indexed transactionId,\n        uint256 indexed projectId,\n        uint256 amount,\n        TransactionType transactionType,\n        address indexed recipient\n    );\n    \n    event DonationReceived(\n        uint256 indexed contributionId,\n        address indexed donor,\n        uint256 amount,\n        uint256 indexed projectId\n    );\n    \n    event TransactionVerified(\n        uint256 indexed transactionId,\n        address indexed verifiedBy,\n        uint256 verificationTimestamp\n    );\n    \n    event BudgetUpdated(\n        uint256 previousTotal,\n        uint256 newTotal,\n        address indexed updatedBy\n    );\n    \n    event TreasurerAuthorized(\n        address indexed treasurer,\n        bool authorized,\n        address indexed authorizedBy\n    );\n    \n    event EmergencyWithdrawal(\n        uint256 amount,\n        address indexed recipient,\n        string reason,\n        address indexed authorizedBy\n    );\n    \n    // Modifiers\n    modifier onlyAuthorizedTreasurer() {\n        require(authorizedTreasurers[msg.sender] || msg.sender == owner(), \n                \"Treasury: Not authorized treasurer\");\n        _;\n    }\n    \n    modifier validProjectId(uint256 _projectId) {\n        require(_projectId > 0 && _projectId <= projectRegistry.getTotalProjects(), \n                \"Treasury: Invalid project ID\");\n        _;\n    }\n    \n    modifier validAllocationId(uint256 _allocationId) {\n        require(_allocationId > 0 && _allocationId <= _allocationIdCounter, \n                \"Treasury: Invalid allocation ID\");\n        _;\n    }\n    \n    modifier validTransactionId(uint256 _transactionId) {\n        require(_transactionId > 0 && _transactionId <= _transactionIdCounter, \n                \"Treasury: Invalid transaction ID\");\n        _;\n    }\n    \n    constructor(\n        address initialOwner,\n        address _projectRegistry,\n        address _citizenRegistry,\n        uint256 _initialBudget\n    ) Ownable(initialOwner) {\n        require(_projectRegistry != address(0), \"Treasury: Invalid project registry\");\n        require(_citizenRegistry != address(0), \"Treasury: Invalid citizen registry\");\n        \n        projectRegistry = GovernmentProjectRegistry(_projectRegistry);\n        citizenRegistry = CitizenIdentityRegistry(_citizenRegistry);\n        \n        budget.totalBudget = _initialBudget;\n        budget.availableBudget = _initialBudget;\n    }\n    \n    /**\n     * @dev Allocate funds to a specific project\n     */\n    function allocateFundsToProject(\n        uint256 _projectId,\n        uint256 _amount,\n        FundSource _source,\n        string memory _ipfsDescriptionHash,\n        string memory _documentHash\n    ) external onlyAuthorizedTreasurer validProjectId(_projectId) nonReentrant {\n        require(_amount > 0, \"Treasury: Amount must be greater than 0\");\n        require(budget.availableBudget >= _amount, \"Treasury: Insufficient available budget\");\n        require(bytes(_ipfsDescriptionHash).length > 0, \"Treasury: IPFS description hash required\");\n        \n        _allocationIdCounter++;\n        uint256 newAllocationId = _allocationIdCounter;\n        \n        // Create allocation record\n        allocations[newAllocationId] = FundAllocation({\n            allocationId: newAllocationId,\n            projectId: _projectId,\n            amount: _amount,\n            source: _source,\n            authorizedBy: msg.sender,\n            timestamp: block.timestamp,\n            ipfsDescriptionHash: _ipfsDescriptionHash,\n            isActive: true,\n            documentHash: _documentHash\n        });\n        \n        // Update budget tracking\n        budget.allocatedBudget += _amount;\n        budget.availableBudget -= _amount;\n        budget.projectAllocations[_projectId] += _amount;\n        \n        // Add to project allocations\n        projectAllocations[_projectId].push(newAllocationId);\n        \n        emit FundsAllocated(newAllocationId, _projectId, _amount, _source, msg.sender);\n    }\n    \n    /**\n     * @dev Record a financial transaction (expenditure)\n     */\n    function recordTransaction(\n        uint256 _projectId,\n        uint256 _amount,\n        TransactionType _transactionType,\n        FundSource _source,\n        address _recipient,\n        string memory _ipfsDescriptionHash,\n        string memory _receiptHash\n    ) external onlyAuthorizedTreasurer validProjectId(_projectId) nonReentrant {\n        require(_amount > 0, \"Treasury: Amount must be greater than 0\");\n        require(_recipient != address(0), \"Treasury: Invalid recipient address\");\n        require(bytes(_ipfsDescriptionHash).length > 0, \"Treasury: IPFS description hash required\");\n        \n        // Validate sufficient allocation for expenditures\n        if (_transactionType == TransactionType.EXPENDITURE) {\n            uint256 availableForProject = budget.projectAllocations[_projectId] - budget.projectSpending[_projectId];\n            require(availableForProject >= _amount, \"Treasury: Insufficient project allocation\");\n            \n            // Update spending tracking\n            budget.spentBudget += _amount;\n            budget.projectSpending[_projectId] += _amount;\n        }\n        \n        _transactionIdCounter++;\n        uint256 newTransactionId = _transactionIdCounter;\n        \n        // Create transaction record\n        transactions[newTransactionId] = FinancialTransaction({\n            transactionId: newTransactionId,\n            projectId: _projectId,\n            amount: _amount,\n            transactionType: _transactionType,\n            source: _source,\n            authorizedBy: msg.sender,\n            recipient: _recipient,\n            timestamp: block.timestamp,\n            ipfsDescriptionHash: _ipfsDescriptionHash,\n            receiptHash: _receiptHash,\n            isVerified: false,\n            verifiedBy: address(0),\n            verificationTimestamp: 0\n        });\n        \n        // Add to project transactions\n        projectTransactions[_projectId].push(newTransactionId);\n        \n        emit TransactionRecorded(newTransactionId, _projectId, _amount, _transactionType, _recipient);\n    }\n    \n    /**\n     * @dev Receive donor contribution\n     */\n    function receiveDonation(\n        uint256 _projectId,\n        string memory _ipfsMessageHash,\n        bool _isAnonymous\n    ) external payable nonReentrant {\n        require(msg.value > 0, \"Treasury: Donation amount must be greater than 0\");\n        \n        // If project ID is provided, validate it\n        if (_projectId > 0) {\n            require(_projectId <= projectRegistry.getTotalProjects(), \"Treasury: Invalid project ID\");\n        }\n        \n        _contributionIdCounter++;\n        uint256 newContributionId = _contributionIdCounter;\n        \n        // Create contribution record\n        contributions[newContributionId] = DonorContribution({\n            contributionId: newContributionId,\n            donor: msg.sender,\n            amount: msg.value,\n            projectId: _projectId,\n            timestamp: block.timestamp,\n            ipfsMessageHash: _ipfsMessageHash,\n            isAnonymous: _isAnonymous,\n            isRefunded: false\n        });\n        \n        // Update budget\n        budget.totalBudget += msg.value;\n        budget.availableBudget += msg.value;\n        \n        // Add to donor contributions\n        donorContributions[msg.sender].push(newContributionId);\n        \n        emit DonationReceived(newContributionId, msg.sender, msg.value, _projectId);\n    }\n    \n    /**\n     * @dev Verify a transaction (by authorized verifiers)\n     */\n    function verifyTransaction(uint256 _transactionId) external validTransactionId(_transactionId) {\n        // Check if caller is authorized (government entity, treasurer, or admin)\n        require(\n            authorizedTreasurers[msg.sender] || \n            msg.sender == owner() ||\n            _isAuthorizedVerifier(msg.sender),\n            \"Treasury: Not authorized to verify transactions\"\n        );\n        \n        FinancialTransaction storage transaction = transactions[_transactionId];\n        require(!transaction.isVerified, \"Treasury: Transaction already verified\");\n        require(transaction.authorizedBy != msg.sender, \"Treasury: Cannot verify own transaction\");\n        \n        transaction.isVerified = true;\n        transaction.verifiedBy = msg.sender;\n        transaction.verificationTimestamp = block.timestamp;\n        \n        emit TransactionVerified(_transactionId, msg.sender, block.timestamp);\n    }\n    \n    /**\n     * @dev Transfer funds between projects\n     */\n    function transferFundsBetweenProjects(\n        uint256 _fromProjectId,\n        uint256 _toProjectId,\n        uint256 _amount,\n        string memory _reason\n    ) external onlyAuthorizedTreasurer nonReentrant {\n        require(_fromProjectId != _toProjectId, \"Treasury: Cannot transfer to same project\");\n        require(_amount > 0, \"Treasury: Amount must be greater than 0\");\n        require(bytes(_reason).length > 0, \"Treasury: Reason required\");\n        \n        // Validate projects exist\n        require(_fromProjectId <= projectRegistry.getTotalProjects(), \"Treasury: Invalid from project\");\n        require(_toProjectId <= projectRegistry.getTotalProjects(), \"Treasury: Invalid to project\");\n        \n        // Check available funds in source project\n        uint256 availableInSource = budget.projectAllocations[_fromProjectId] - budget.projectSpending[_fromProjectId];\n        require(availableInSource >= _amount, \"Treasury: Insufficient funds in source project\");\n        \n        // Update allocations\n        budget.projectAllocations[_fromProjectId] -= _amount;\n        budget.projectAllocations[_toProjectId] += _amount;\n        \n        // Record transfer transactions\n        _transactionIdCounter++;\n        uint256 transferOutId = _transactionIdCounter;\n        \n        transactions[transferOutId] = FinancialTransaction({\n            transactionId: transferOutId,\n            projectId: _fromProjectId,\n            amount: _amount,\n            transactionType: TransactionType.TRANSFER,\n            source: FundSource.GOVERNMENT_BUDGET,\n            authorizedBy: msg.sender,\n            recipient: address(this),\n            timestamp: block.timestamp,\n            ipfsDescriptionHash: \"\", // Simple transfer descriptions don't need IPFS\n            receiptHash: \"\",\n            isVerified: true, // Auto-verified for internal transfers\n            verifiedBy: msg.sender,\n            verificationTimestamp: block.timestamp\n        });\n        \n        projectTransactions[_fromProjectId].push(transferOutId);\n        \n        _transactionIdCounter++;\n        uint256 transferInId = _transactionIdCounter;\n        \n        transactions[transferInId] = FinancialTransaction({\n            transactionId: transferInId,\n            projectId: _toProjectId,\n            amount: _amount,\n            transactionType: TransactionType.ALLOCATION,\n            source: FundSource.GOVERNMENT_BUDGET,\n            authorizedBy: msg.sender,\n            recipient: address(this),\n            timestamp: block.timestamp,\n            ipfsDescriptionHash: \"\", // Simple transfer descriptions don't need IPFS\n            receiptHash: \"\",\n            isVerified: true, // Auto-verified for internal transfers\n            verifiedBy: msg.sender,\n            verificationTimestamp: block.timestamp\n        });\n        \n        projectTransactions[_toProjectId].push(transferInId);\n        \n        emit TransactionRecorded(transferOutId, _fromProjectId, _amount, TransactionType.TRANSFER, address(this));\n        emit TransactionRecorded(transferInId, _toProjectId, _amount, TransactionType.ALLOCATION, address(this));\n    }\n    \n    // View functions\n    function getBudgetOverview() external view returns (\n        uint256 totalBudget,\n        uint256 allocatedBudget,\n        uint256 spentBudget,\n        uint256 availableBudget,\n        uint256 utilizationPercentage\n    ) {\n        uint256 utilization = budget.totalBudget > 0 ? (budget.spentBudget * 10000) / budget.totalBudget : 0;\n        \n        return (\n            budget.totalBudget,\n            budget.allocatedBudget,\n            budget.spentBudget,\n            budget.availableBudget,\n            utilization\n        );\n    }\n    \n    function getProjectFinancials(uint256 _projectId) external view validProjectId(_projectId) returns (\n        uint256 allocatedAmount,\n        uint256 spentAmount,\n        uint256 availableAmount,\n        uint256 transactionCount,\n        uint256 utilizationPercentage\n    ) {\n        uint256 allocated = budget.projectAllocations[_projectId];\n        uint256 spent = budget.projectSpending[_projectId];\n        uint256 available = allocated > spent ? allocated - spent : 0;\n        uint256 utilization = allocated > 0 ? (spent * 10000) / allocated : 0;\n        \n        return (\n            allocated,\n            spent,\n            available,\n            projectTransactions[_projectId].length,\n            utilization\n        );\n    }\n    \n    function getProjectTransactions(uint256 _projectId) external view validProjectId(_projectId) returns (uint256[] memory) {\n        return projectTransactions[_projectId];\n    }\n    \n    function getProjectAllocations(uint256 _projectId) external view validProjectId(_projectId) returns (uint256[] memory) {\n        return projectAllocations[_projectId];\n    }\n    \n    function getDonorContributions(address _donor) external view returns (uint256[] memory) {\n        return donorContributions[_donor];\n    }\n    \n    function getTotalContributions() external view returns (uint256 totalAmount, uint256 totalCount) {\n        uint256 total = 0;\n        for (uint256 i = 1; i <= _contributionIdCounter; i++) {\n            if (!contributions[i].isRefunded) {\n                total += contributions[i].amount;\n            }\n        }\n        return (total, _contributionIdCounter);\n    }\n    \n    function getUnverifiedTransactions() external view returns (uint256[] memory) {\n        uint256 count = 0;\n        \n        // Count unverified transactions\n        for (uint256 i = 1; i <= _transactionIdCounter; i++) {\n            if (!transactions[i].isVerified) {\n                count++;\n            }\n        }\n        \n        // Create result array\n        uint256[] memory unverifiedIds = new uint256[](count);\n        uint256 index = 0;\n        \n        for (uint256 i = 1; i <= _transactionIdCounter; i++) {\n            if (!transactions[i].isVerified) {\n                unverifiedIds[index] = i;\n                index++;\n            }\n        }\n        \n        return unverifiedIds;\n    }\n    \n    function getContractBalance() external view returns (uint256) {\n        return address(this).balance;\n    }\n    \n    // Internal functions\n    function _isAuthorizedVerifier(address _verifier) internal view returns (bool) {\n        // Check if verifier is a registered citizen with sufficient reputation\n        try citizenRegistry.isCitizenRegistered(_verifier) returns (bool isRegistered) {\n            if (!isRegistered) return false;\n            \n            // Add reputation threshold check when reputation system is integrated\n            // For now, any registered citizen can verify\n            return true;\n        } catch {\n            return false;\n        }\n    }\n    \n    // Admin functions\n    function updateBudget(uint256 _newTotalBudget) external onlyOwner {\n        require(_newTotalBudget >= budget.spentBudget, \"Treasury: New budget less than already spent\");\n        \n        uint256 previousBudget = budget.totalBudget;\n        \n        if (_newTotalBudget > budget.totalBudget) {\n            // Budget increase\n            budget.availableBudget += (_newTotalBudget - budget.totalBudget);\n        } else if (_newTotalBudget < budget.totalBudget) {\n            // Budget decrease\n            uint256 decrease = budget.totalBudget - _newTotalBudget;\n            budget.availableBudget = budget.availableBudget > decrease ? budget.availableBudget - decrease : 0;\n        }\n        \n        budget.totalBudget = _newTotalBudget;\n        \n        emit BudgetUpdated(previousBudget, _newTotalBudget, msg.sender);\n    }\n    \n    function authorizeTreasurer(address _treasurer, bool _authorized) external onlyOwner {\n        require(_treasurer != address(0), \"Treasury: Invalid treasurer address\");\n        authorizedTreasurers[_treasurer] = _authorized;\n        emit TreasurerAuthorized(_treasurer, _authorized, msg.sender);\n    }\n    \n    function emergencyWithdraw(uint256 _amount, address payable _recipient, string memory _reason) external onlyOwner {\n        require(_amount > 0, \"Treasury: Amount must be greater than 0\");\n        require(_recipient != address(0), \"Treasury: Invalid recipient\");\n        require(address(this).balance >= _amount, \"Treasury: Insufficient contract balance\");\n        require(bytes(_reason).length > 0, \"Treasury: Reason required\");\n        \n        _recipient.transfer(_amount);\n        \n        emit EmergencyWithdrawal(_amount, _recipient, _reason, msg.sender);\n    }\n    \n    function refundDonation(uint256 _contributionId) external onlyOwner {\n        require(_contributionId > 0 && _contributionId <= _contributionIdCounter, \"Treasury: Invalid contribution ID\");\n        \n        DonorContribution storage contribution = contributions[_contributionId];\n        require(!contribution.isRefunded, \"Treasury: Already refunded\");\n        require(address(this).balance >= contribution.amount, \"Treasury: Insufficient balance for refund\");\n        \n        contribution.isRefunded = true;\n        budget.totalBudget -= contribution.amount;\n        budget.availableBudget = budget.availableBudget > contribution.amount ? \n                                budget.availableBudget - contribution.amount : 0;\n        \n        payable(contribution.donor).transfer(contribution.amount);\n    }\n    \n    // Allow contract to receive donations\n    receive() external payable {\n        // Donations received without explicit project assignment go to general fund\n        _contributionIdCounter++;\n        uint256 newContributionId = _contributionIdCounter;\n        \n        contributions[newContributionId] = DonorContribution({\n            contributionId: newContributionId,\n            donor: msg.sender,\n            amount: msg.value,\n            projectId: 0, // General fund\n            timestamp: block.timestamp,\n            ipfsMessageHash: \"\", // Simple direct donation message\n            isAnonymous: false,\n            isRefunded: false\n        });\n        \n        budget.totalBudget += msg.value;\n        budget.availableBudget += msg.value;\n        \n        donorContributions[msg.sender].push(newContributionId);\n        \n        emit DonationReceived(newContributionId, msg.sender, msg.value, 0);\n    }\n}"
    },
    "contracts/VerificationAuditSystem.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./CitizenIdentityRegistry.sol\";\nimport \"./ReputationSystem.sol\";\nimport \"./IssueReportingSystem.sol\";\nimport \"./GovernmentProjectRegistry.sol\";\n\n/**\n * @title VerificationAuditSystem\n * @dev Manages verification workflows and audit trails\n * @author CitiProof Team\n */\ncontract VerificationAuditSystem is Ownable, ReentrancyGuard {\n    \n    CitizenIdentityRegistry public immutable citizenRegistry;\n    ReputationSystem public reputationSystem;\n    IssueReportingSystem public issueReportingSystem;\n    GovernmentProjectRegistry public projectRegistry;\n    \n    enum VerificationType {\n        ISSUE_VERIFICATION,      // Verifying issue reports\n        PROJECT_MILESTONE,       // Verifying project completion\n        BUDGET_EXPENDITURE,      // Verifying financial transactions\n        DOCUMENT_AUTHENTICITY,   // Verifying document legitimacy\n        COMPLIANCE_CHECK        // Verifying regulatory compliance\n    }\n    \n    enum VerificationStatus {\n        PENDING,        // Awaiting verification\n        IN_PROGRESS,    // Being verified\n        VERIFIED,       // Successfully verified\n        DISPUTED,       // Verification disputed\n        REJECTED,       // Verification failed\n        EXPIRED         // Verification period expired\n    }\n    \n    struct VerificationRequest {\n        uint256 requestId;\n        uint256 submitterCitizenId;\n        address submitter;\n        VerificationType verificationType;\n        VerificationStatus status;\n        string title; // Keep on-chain for indexing\n        string ipfsDescriptionHash; // IPFS hash for detailed description\n        string evidenceHash; // IPFS hash for evidence\n        uint256 relatedEntityId; // Related issue/project/transaction ID\n        uint256 submissionTimestamp;\n        uint256 deadline;\n        uint256 requiredVerifications;\n        uint256 completedVerifications;\n        uint256 reputationReward;\n        bool isPaid;\n        string[] tags; // Keep on-chain for filtering\n    }\n    \n    struct VerificationResponse {\n        uint256 verifierCitizenId;\n        address verifier;\n        bool isApproved;\n        string ipfsFindingsHash; // IPFS hash for detailed findings\n        string evidenceHash; // Additional evidence from verifier\n        uint256 timestamp;\n        uint256 verifierReputationAtTime;\n        bool isDisputed;\n    }\n    \n    struct AuditTrail {\n        uint256 auditId;\n        uint256 relatedEntityId;\n        VerificationType entityType;\n        string action; // Keep action type on-chain for indexing\n        address performedBy;\n        uint256 timestamp;\n        string ipfsDetailsHash; // IPFS hash for detailed audit information\n        bytes32 dataHash; // Hash of the state before action\n        bool isReversible;\n    }\n    \n    // Storage\n    uint256 private _verificationRequestIdCounter;\n    uint256 private _auditTrailIdCounter;\n    \n    mapping(uint256 => VerificationRequest) public verificationRequests;\n    mapping(uint256 => VerificationResponse[]) public verificationResponses;\n    mapping(uint256 => mapping(uint256 => bool)) public hasVerified; // requestId => citizenId => verified\n    mapping(uint256 => AuditTrail) public auditTrail;\n    mapping(uint256 => uint256[]) public entityAudits; // entityId => auditIds\n    mapping(address => uint256[]) public citizenVerifications; // citizen => requestIds\n    mapping(address => bool) public authorizedAuditors;\n    \n    // Configuration\n    uint256 public defaultVerificationDeadline = 3 days;\n    uint256 public minimumReputationToVerify = 100;\n    uint256 public baseVerificationReward = 25;\n    uint256 public disputePenalty = 50;\n    \n    // Events\n    event VerificationRequested(\n        uint256 indexed requestId,\n        uint256 indexed submitterCitizenId,\n        VerificationType verificationType,\n        uint256 relatedEntityId\n    );\n    \n    event VerificationCompleted(\n        uint256 indexed requestId,\n        uint256 indexed verifierCitizenId,\n        address indexed verifier,\n        bool isApproved\n    );\n    \n    event VerificationFinalized(\n        uint256 indexed requestId,\n        VerificationStatus finalStatus,\n        uint256 totalVerifications\n    );\n    \n    event VerificationDisputed(\n        uint256 indexed requestId,\n        uint256 indexed disputerCitizenId,\n        address indexed disputer\n    );\n    \n    event AuditRecorded(\n        uint256 indexed auditId,\n        uint256 indexed relatedEntityId,\n        string action,\n        address indexed performedBy\n    );\n    \n    // Modifiers\n    modifier onlyRegisteredCitizen() {\n        require(citizenRegistry.isCitizenRegistered(msg.sender), \"Verification: Must be registered citizen\");\n        _;\n    }\n    \n    modifier onlyAuthorizedAuditor() {\n        require(authorizedAuditors[msg.sender] || msg.sender == owner(), \n                \"Verification: Not authorized auditor\");\n        _;\n    }\n    \n    modifier validRequestId(uint256 _requestId) {\n        require(_requestId > 0 && _requestId <= _verificationRequestIdCounter, \n                \"Verification: Invalid request ID\");\n        _;\n    }\n    \n    constructor(\n        address initialOwner,\n        address _citizenRegistry,\n        address _reputationSystem\n    ) Ownable(initialOwner) {\n        require(_citizenRegistry != address(0), \"Verification: Invalid citizen registry\");\n        require(_reputationSystem != address(0), \"Verification: Invalid reputation system\");\n        \n        citizenRegistry = CitizenIdentityRegistry(_citizenRegistry);\n        reputationSystem = ReputationSystem(_reputationSystem);\n    }\n    \n    /**\n     * @dev Submit a verification request\n     */\n    function submitVerificationRequest(\n        VerificationType _verificationType,\n        string memory _title,\n        string memory _description,\n        string memory _evidenceHash,\n        uint256 _relatedEntityId,\n        uint256 _requiredVerifications,\n        string[] memory _tags\n    ) external onlyRegisteredCitizen nonReentrant {\n        require(bytes(_title).length > 0, \"Verification: Title cannot be empty\");\n        require(bytes(_description).length > 10, \"Verification: Description too short\");\n        require(_requiredVerifications > 0 && _requiredVerifications <= 10, \n                \"Verification: Invalid verification count\");\n        \n        // Get submitter's citizen ID\n        uint256 submitterCitizenId = 0;\n        try citizenRegistry.getCitizenByWallet(msg.sender) returns (CitizenIdentityRegistry.CitizenProfile memory profile) {\n            submitterCitizenId = profile.citizenId;\n        } catch {\n            revert(\"Verification: Failed to get citizen profile\");\n        }\n        \n        _verificationRequestIdCounter++;\n        uint256 newRequestId = _verificationRequestIdCounter;\n        \n        verificationRequests[newRequestId] = VerificationRequest({\n            requestId: newRequestId,\n            submitterCitizenId: submitterCitizenId,\n            submitter: msg.sender,\n            verificationType: _verificationType,\n            status: VerificationStatus.PENDING,\n            title: _title,\n            ipfsDescriptionHash: _description,\n            evidenceHash: _evidenceHash,\n            relatedEntityId: _relatedEntityId,\n            submissionTimestamp: block.timestamp,\n            deadline: block.timestamp + defaultVerificationDeadline,\n            requiredVerifications: _requiredVerifications,\n            completedVerifications: 0,\n            reputationReward: baseVerificationReward,\n            isPaid: false,\n            tags: _tags\n        });\n        \n        citizenVerifications[msg.sender].push(newRequestId);\n        \n        // Record audit trail\n        _recordAudit(\n            _relatedEntityId,\n            _verificationType,\n            \"Verification requested\",\n            msg.sender,\n            \"Verification request submitted for review\"\n        );\n        \n        emit VerificationRequested(newRequestId, submitterCitizenId, _verificationType, _relatedEntityId);\n    }\n    \n    /**\n     * @dev Complete verification for a request\n     */\n    function completeVerification(\n        uint256 _requestId,\n        bool _isApproved,\n        string memory _findings,\n        string memory _additionalEvidenceHash\n    ) external onlyRegisteredCitizen validRequestId(_requestId) {\n        VerificationRequest storage request = verificationRequests[_requestId];\n        require(request.status == VerificationStatus.PENDING || request.status == VerificationStatus.IN_PROGRESS, \n                \"Verification: Request not open for verification\");\n        require(block.timestamp <= request.deadline, \"Verification: Verification deadline passed\");\n        \n        // Get verifier's citizen ID and reputation\n        uint256 verifierCitizenId = 0;\n        uint256 verifierReputation = 0;\n        \n        try citizenRegistry.getCitizenByWallet(msg.sender) returns (CitizenIdentityRegistry.CitizenProfile memory profile) {\n            verifierCitizenId = profile.citizenId;\n            verifierReputation = profile.reputationScore;\n        } catch {\n            revert(\"Verification: Failed to get citizen profile\");\n        }\n        \n        require(verifierReputation >= minimumReputationToVerify, \n                \"Verification: Insufficient reputation to verify\");\n        require(!hasVerified[_requestId][verifierCitizenId], \n                \"Verification: Already verified this request\");\n        require(request.submitterCitizenId != verifierCitizenId, \n                \"Verification: Cannot verify own request\");\n        \n        // Record verification response\n        verificationResponses[_requestId].push(VerificationResponse({\n            verifierCitizenId: verifierCitizenId,\n            verifier: msg.sender,\n            isApproved: _isApproved,\n            ipfsFindingsHash: _findings,\n            evidenceHash: _additionalEvidenceHash,\n            timestamp: block.timestamp,\n            verifierReputationAtTime: verifierReputation,\n            isDisputed: false\n        }));\n        \n        hasVerified[_requestId][verifierCitizenId] = true;\n        request.completedVerifications++;\n        \n        // Update status to in progress if first verification\n        if (request.status == VerificationStatus.PENDING) {\n            request.status = VerificationStatus.IN_PROGRESS;\n        }\n        \n        emit VerificationCompleted(_requestId, verifierCitizenId, msg.sender, _isApproved);\n        \n        // Award reputation for verification\n        bytes32 verificationHash = keccak256(abi.encodePacked(\"verification\", _requestId));\n        try reputationSystem.addVerificationReputation(verifierCitizenId, verificationHash) {} catch {}\n        \n        // Check if verification is complete\n        if (request.completedVerifications >= request.requiredVerifications) {\n            _finalizeVerification(_requestId);\n        }\n    }\n    \n    /**\n     * @dev Dispute a verification\n     */\n    function disputeVerification(\n        uint256 _requestId,\n        uint256 _responseIndex,\n        string memory _disputeReason\n    ) external onlyRegisteredCitizen validRequestId(_requestId) {\n        require(_responseIndex < verificationResponses[_requestId].length, \n                \"Verification: Invalid response index\");\n        require(bytes(_disputeReason).length > 10, \"Verification: Dispute reason too short\");\n        \n        VerificationResponse storage response = verificationResponses[_requestId][_responseIndex];\n        require(!response.isDisputed, \"Verification: Already disputed\");\n        require(response.verifier != msg.sender, \"Verification: Cannot dispute own verification\");\n        \n        // Get disputer's citizen ID and reputation\n        uint256 disputerCitizenId = 0;\n        uint256 disputerReputation = 0;\n        \n        try citizenRegistry.getCitizenByWallet(msg.sender) returns (CitizenIdentityRegistry.CitizenProfile memory profile) {\n            disputerCitizenId = profile.citizenId;\n            disputerReputation = profile.reputationScore;\n        } catch {\n            revert(\"Verification: Failed to get citizen profile\");\n        }\n        \n        require(disputerReputation >= minimumReputationToVerify, \n                \"Verification: Insufficient reputation to dispute\");\n        \n        response.isDisputed = true;\n        verificationRequests[_requestId].status = VerificationStatus.DISPUTED;\n        \n        // Record audit trail\n        _recordAudit(\n            verificationRequests[_requestId].relatedEntityId,\n            verificationRequests[_requestId].verificationType,\n            \"Verification disputed\",\n            msg.sender,\n            _disputeReason\n        );\n        \n        emit VerificationDisputed(_requestId, disputerCitizenId, msg.sender);\n    }\n    \n    /**\n     * @dev Record audit trail entry\n     */\n    function recordAudit(\n        uint256 _relatedEntityId,\n        VerificationType _entityType,\n        string memory _action,\n        string memory _details\n    ) external onlyAuthorizedAuditor {\n        _recordAudit(_relatedEntityId, _entityType, _action, msg.sender, _details);\n    }\n    \n    // View functions\n    function getVerificationRequest(uint256 _requestId) external view validRequestId(_requestId) returns (VerificationRequest memory) {\n        return verificationRequests[_requestId];\n    }\n    \n    function getVerificationResponses(uint256 _requestId) external view validRequestId(_requestId) returns (VerificationResponse[] memory) {\n        return verificationResponses[_requestId];\n    }\n    \n    function getCitizenVerifications(address _citizen) external view returns (uint256[] memory) {\n        return citizenVerifications[_citizen];\n    }\n    \n    function getEntityAuditTrail(uint256 _entityId) external view returns (uint256[] memory) {\n        return entityAudits[_entityId];\n    }\n    \n    function getPendingVerifications() external view returns (uint256[] memory) {\n        uint256 count = 0;\n        \n        // Count pending verifications\n        for (uint256 i = 1; i <= _verificationRequestIdCounter; i++) {\n            if (verificationRequests[i].status == VerificationStatus.PENDING || \n                verificationRequests[i].status == VerificationStatus.IN_PROGRESS) {\n                if (block.timestamp <= verificationRequests[i].deadline) {\n                    count++;\n                }\n            }\n        }\n        \n        // Create result array\n        uint256[] memory pending = new uint256[](count);\n        uint256 index = 0;\n        \n        for (uint256 i = 1; i <= _verificationRequestIdCounter; i++) {\n            if (verificationRequests[i].status == VerificationStatus.PENDING || \n                verificationRequests[i].status == VerificationStatus.IN_PROGRESS) {\n                if (block.timestamp <= verificationRequests[i].deadline) {\n                    pending[index] = i;\n                    index++;\n                }\n            }\n        }\n        \n        return pending;\n    }\n    \n    function getVerificationStats() external view returns (\n        uint256 totalRequests,\n        uint256 pendingRequests,\n        uint256 verifiedRequests,\n        uint256 disputedRequests\n    ) {\n        uint256 pending = 0;\n        uint256 verified = 0;\n        uint256 disputed = 0;\n        \n        for (uint256 i = 1; i <= _verificationRequestIdCounter; i++) {\n            VerificationStatus status = verificationRequests[i].status;\n            \n            if (status == VerificationStatus.PENDING || status == VerificationStatus.IN_PROGRESS) {\n                pending++;\n            } else if (status == VerificationStatus.VERIFIED) {\n                verified++;\n            } else if (status == VerificationStatus.DISPUTED) {\n                disputed++;\n            }\n        }\n        \n        return (_verificationRequestIdCounter, pending, verified, disputed);\n    }\n    \n    // Internal functions\n    function _finalizeVerification(uint256 _requestId) internal {\n        VerificationRequest storage request = verificationRequests[_requestId];\n        VerificationResponse[] storage responses = verificationResponses[_requestId];\n        \n        uint256 approvedCount = 0;\n        uint256 totalWeight = 0;\n        uint256 approvedWeight = 0;\n        \n        // Calculate weighted approval\n        for (uint256 i = 0; i < responses.length; i++) {\n            if (!responses[i].isDisputed) {\n                uint256 weight = _calculateVerificationWeight(responses[i].verifierReputationAtTime);\n                totalWeight += weight;\n                \n                if (responses[i].isApproved) {\n                    approvedCount++;\n                    approvedWeight += weight;\n                }\n            }\n        }\n        \n        // Determine final status\n        VerificationStatus finalStatus;\n        if (totalWeight == 0) {\n            finalStatus = VerificationStatus.REJECTED;\n        } else {\n            uint256 approvalPercentage = (approvedWeight * 100) / totalWeight;\n            finalStatus = approvalPercentage >= 60 ? VerificationStatus.VERIFIED : VerificationStatus.REJECTED;\n        }\n        \n        request.status = finalStatus;\n        \n        // Record audit trail\n        _recordAudit(\n            request.relatedEntityId,\n            request.verificationType,\n            finalStatus == VerificationStatus.VERIFIED ? \"Verification approved\" : \"Verification rejected\",\n            address(this),\n            string(abi.encodePacked(\"Final verification result with \", approvedCount, \" approvals\"))\n        );\n        \n        emit VerificationFinalized(_requestId, finalStatus, request.completedVerifications);\n    }\n    \n    function _calculateVerificationWeight(uint256 _reputation) internal pure returns (uint256) {\n        // Weight verification based on verifier reputation\n        if (_reputation >= 1000) return 5;       // High reputation verifiers have more weight\n        else if (_reputation >= 500) return 3;   // Medium reputation\n        else if (_reputation >= 200) return 2;   // Good reputation\n        else return 1;                           // Basic reputation\n    }\n    \n    function _recordAudit(\n        uint256 _relatedEntityId,\n        VerificationType _entityType,\n        string memory _action,\n        address _performedBy,\n        string memory _details\n    ) internal {\n        _auditTrailIdCounter++;\n        uint256 newAuditId = _auditTrailIdCounter;\n        \n        bytes32 dataHash = keccak256(abi.encodePacked(\n            _relatedEntityId,\n            _action,\n            _performedBy,\n            block.timestamp,\n            _details\n        ));\n        \n        auditTrail[newAuditId] = AuditTrail({\n            auditId: newAuditId,\n            relatedEntityId: _relatedEntityId,\n            entityType: _entityType,\n            action: _action,\n            performedBy: _performedBy,\n            timestamp: block.timestamp,\n            ipfsDetailsHash: _details,\n            dataHash: dataHash,\n            isReversible: false\n        });\n        \n        entityAudits[_relatedEntityId].push(newAuditId);\n        \n        emit AuditRecorded(newAuditId, _relatedEntityId, _action, _performedBy);\n    }\n    \n    // Admin functions\n    function updateConfiguration(\n        uint256 _defaultVerificationDeadline,\n        uint256 _minimumReputationToVerify,\n        uint256 _baseVerificationReward\n    ) external onlyOwner {\n        require(_defaultVerificationDeadline >= 1 days, \"Verification: Deadline too short\");\n        require(_minimumReputationToVerify > 0, \"Verification: Invalid reputation requirement\");\n        \n        defaultVerificationDeadline = _defaultVerificationDeadline;\n        minimumReputationToVerify = _minimumReputationToVerify;\n        baseVerificationReward = _baseVerificationReward;\n    }\n    \n    function authorizeAuditor(address _auditor, bool _authorized) external onlyOwner {\n        require(_auditor != address(0), \"Verification: Invalid auditor address\");\n        authorizedAuditors[_auditor] = _authorized;\n    }\n    \n    function setExternalContracts(\n        address _issueReportingSystem,\n        address _projectRegistry\n    ) external onlyOwner {\n        if (_issueReportingSystem != address(0)) {\n            issueReportingSystem = IssueReportingSystem(_issueReportingSystem);\n        }\n        if (_projectRegistry != address(0)) {\n            projectRegistry = GovernmentProjectRegistry(_projectRegistry);\n        }\n    }\n    \n    function forceResolveDispute(\n        uint256 _requestId,\n        VerificationStatus _finalStatus\n    ) external onlyOwner validRequestId(_requestId) {\n        require(verificationRequests[_requestId].status == VerificationStatus.DISPUTED, \n                \"Verification: Request not disputed\");\n        require(_finalStatus == VerificationStatus.VERIFIED || _finalStatus == VerificationStatus.REJECTED, \n                \"Verification: Invalid final status\");\n        \n        verificationRequests[_requestId].status = _finalStatus;\n        \n        _recordAudit(\n            verificationRequests[_requestId].relatedEntityId,\n            verificationRequests[_requestId].verificationType,\n            \"Dispute resolved by admin\",\n            msg.sender,\n            string(abi.encodePacked(\"Admin resolution: \", _finalStatus == VerificationStatus.VERIFIED ? \"Approved\" : \"Rejected\"))\n        );\n        \n        emit VerificationFinalized(_requestId, _finalStatus, verificationRequests[_requestId].completedVerifications);\n    }\n}"
    },
    "contracts/VotingGovernanceSystem.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./CitizenIdentityRegistry.sol\";\nimport \"./ReputationSystem.sol\";\nimport \"./GovernmentProjectRegistry.sol\";\n\n/**\n * @title VotingGovernanceSystem\n * @dev Enables community voting on governance matters\n * @author CitiProof Team\n */\ncontract VotingGovernanceSystem is Ownable, ReentrancyGuard {\n    \n    CitizenIdentityRegistry public immutable citizenRegistry;\n    ReputationSystem public reputationSystem;\n    GovernmentProjectRegistry public projectRegistry;\n    \n    enum ProposalType {\n        PROJECT_APPROVAL,    // Vote on new project proposals\n        BUDGET_ALLOCATION,   // Vote on budget changes\n        POLICY_CHANGE,       // Vote on governance policy updates\n        ISSUE_PRIORITY,      // Vote on issue priority/urgency\n        OTHER\n    }\n    \n    enum ProposalStatus {\n        ACTIVE,      // Currently accepting votes\n        PASSED,      // Proposal passed and executed\n        REJECTED,    // Proposal failed to meet threshold\n        EXPIRED,     // Voting period ended without resolution\n        CANCELLED    // Cancelled by creator or admin\n    }\n    \n    struct Proposal {\n        uint256 proposalId;\n        uint256 creatorCitizenId;\n        address creator;\n        string title;\n        string ipfsDescriptionHash; // IPFS hash for detailed description\n        ProposalType proposalType;\n        ProposalStatus status;\n        uint256 creationTimestamp;\n        uint256 votingEndTimestamp;\n        uint256 executionTimestamp;\n        uint256 yesVotes;\n        uint256 noVotes;\n        uint256 totalVotingPower;\n        uint256 quorumRequired;\n        uint256 passingThreshold; // Percentage needed to pass (basis points)\n        bytes executionData; // Data for automatic execution\n        string ipfsDocumentHash; // Additional proposal documents\n        bool isExecuted;\n        uint256 relatedProjectId; // If related to a specific project\n    }\n    \n    struct Vote {\n        uint256 citizenId;\n        address voter;\n        bool support; // true = yes, false = no\n        uint256 votingPower; // Based on reputation at time of vote\n        uint256 timestamp;\n        string reason; // Optional reason for vote\n    }\n    \n    // Storage\n    uint256 private _proposalIdCounter;\n    mapping(uint256 => Proposal) public proposals;\n    mapping(uint256 => Vote[]) public proposalVotes; // proposalId => Vote[]\n    mapping(uint256 => mapping(uint256 => bool)) public hasVoted; // proposalId => citizenId => voted\n    mapping(address => uint256[]) public citizenProposals; // creator => proposalIds\n    mapping(uint256 => uint256[]) public typeProposals; // proposalType => proposalIds\n    \n    // Configuration\n    uint256 public defaultVotingPeriod = 7 days;\n    uint256 public minimumQuorum = 1000; // Minimum total voting power required\n    uint256 public defaultPassingThreshold = 5100; // 51% in basis points\n    uint256 public minimumReputationToPropose = 100;\n    uint256 public minimumReputationToVote = 50;\n    \n    // Events\n    event ProposalCreated(\n        uint256 indexed proposalId,\n        uint256 indexed creatorCitizenId,\n        address indexed creator,\n        ProposalType proposalType,\n        string title\n    );\n    \n    event VoteCast(\n        uint256 indexed proposalId,\n        uint256 indexed citizenId,\n        address indexed voter,\n        bool support,\n        uint256 votingPower\n    );\n    \n    event ProposalExecuted(\n        uint256 indexed proposalId,\n        ProposalStatus finalStatus,\n        uint256 yesVotes,\n        uint256 noVotes\n    );\n    \n    event ProposalStatusChanged(\n        uint256 indexed proposalId,\n        ProposalStatus oldStatus,\n        ProposalStatus newStatus\n    );\n    \n    // Modifiers\n    modifier onlyRegisteredCitizen() {\n        require(citizenRegistry.isCitizenRegistered(msg.sender), \"Voting: Must be registered citizen\");\n        _;\n    }\n    \n    modifier validProposalId(uint256 _proposalId) {\n        require(_proposalId > 0 && _proposalId <= _proposalIdCounter, \"Voting: Invalid proposal ID\");\n        _;\n    }\n    \n    modifier onlyProposalCreator(uint256 _proposalId) {\n        require(proposals[_proposalId].creator == msg.sender, \"Voting: Not proposal creator\");\n        _;\n    }\n    \n    modifier proposalActive(uint256 _proposalId) {\n        require(proposals[_proposalId].status == ProposalStatus.ACTIVE, \"Voting: Proposal not active\");\n        require(block.timestamp <= proposals[_proposalId].votingEndTimestamp, \"Voting: Voting period ended\");\n        _;\n    }\n    \n    constructor(\n        address initialOwner,\n        address _citizenRegistry,\n        address _reputationSystem,\n        address _projectRegistry\n    ) Ownable(initialOwner) {\n        require(_citizenRegistry != address(0), \"Voting: Invalid citizen registry\");\n        require(_reputationSystem != address(0), \"Voting: Invalid reputation system\");\n        require(_projectRegistry != address(0), \"Voting: Invalid project registry\");\n        \n        citizenRegistry = CitizenIdentityRegistry(_citizenRegistry);\n        reputationSystem = ReputationSystem(_reputationSystem);\n        projectRegistry = GovernmentProjectRegistry(_projectRegistry);\n    }\n    \n    /**\n     * @dev Create a new governance proposal (simplified to avoid stack too deep)\n     */\n    function createProposal(\n        string memory _title,\n        string memory _description,\n        ProposalType _proposalType,\n        uint256 _votingPeriod,\n        uint256 _relatedProjectId\n    ) external onlyRegisteredCitizen nonReentrant {\n        require(bytes(_title).length > 0, \"Voting: Title cannot be empty\");\n        require(bytes(_description).length > 10, \"Voting: Description too short\");\n        \n        // Get creator's citizen ID and check reputation\n        uint256 creatorCitizenId = 0;\n        try citizenRegistry.getCitizenByWallet(msg.sender) returns (CitizenIdentityRegistry.CitizenProfile memory profile) {\n            creatorCitizenId = profile.citizenId;\n            require(profile.reputationScore >= minimumReputationToPropose, \"Voting: Insufficient reputation\");\n        } catch {\n            revert(\"Voting: Failed to get citizen profile\");\n        }\n        \n        _proposalIdCounter++;\n        uint256 newProposalId = _proposalIdCounter;\n        \n        proposals[newProposalId] = Proposal({\n            proposalId: newProposalId,\n            creatorCitizenId: creatorCitizenId,\n            creator: msg.sender,\n            title: _title,\n            ipfsDescriptionHash: _description,\n            proposalType: _proposalType,\n            status: ProposalStatus.ACTIVE,\n            creationTimestamp: block.timestamp,\n            votingEndTimestamp: block.timestamp + (_votingPeriod > 0 ? _votingPeriod : defaultVotingPeriod),\n            executionTimestamp: 0,\n            yesVotes: 0,\n            noVotes: 0,\n            totalVotingPower: 0,\n            quorumRequired: minimumQuorum,\n            passingThreshold: defaultPassingThreshold,\n            executionData: \"\",\n            ipfsDocumentHash: \"\",\n            isExecuted: false,\n            relatedProjectId: _relatedProjectId\n        });\n        \n        citizenProposals[msg.sender].push(newProposalId);\n        typeProposals[uint256(_proposalType)].push(newProposalId);\n        \n        emit ProposalCreated(newProposalId, creatorCitizenId, msg.sender, _proposalType, _title);\n    }\n    \n    /**\n     * @dev Cast vote on a proposal\n     */\n    function castVote(\n        uint256 _proposalId,\n        bool _support,\n        string memory _reason\n    ) external onlyRegisteredCitizen validProposalId(_proposalId) proposalActive(_proposalId) {\n        // Get voter's citizen ID and reputation\n        uint256 voterCitizenId = 0;\n        uint256 voterReputation = 0;\n        \n        try citizenRegistry.getCitizenByWallet(msg.sender) returns (CitizenIdentityRegistry.CitizenProfile memory profile) {\n            voterCitizenId = profile.citizenId;\n            voterReputation = profile.reputationScore;\n        } catch {\n            revert(\"Voting: Failed to get citizen profile\");\n        }\n        \n        require(voterReputation >= minimumReputationToVote, \"Voting: Insufficient reputation to vote\");\n        require(!hasVoted[_proposalId][voterCitizenId], \"Voting: Already voted on this proposal\");\n        require(proposals[_proposalId].creatorCitizenId != voterCitizenId, \"Voting: Cannot vote on own proposal\");\n        \n        // Calculate voting power based on reputation\n        uint256 votingPower = _calculateVotingPower(voterReputation);\n        \n        // Record vote\n        proposalVotes[_proposalId].push(Vote({\n            citizenId: voterCitizenId,\n            voter: msg.sender,\n            support: _support,\n            votingPower: votingPower,\n            timestamp: block.timestamp,\n            reason: _reason\n        }));\n        \n        hasVoted[_proposalId][voterCitizenId] = true;\n        \n        // Update proposal vote counts\n        Proposal storage proposal = proposals[_proposalId];\n        proposal.totalVotingPower += votingPower;\n        \n        if (_support) {\n            proposal.yesVotes += votingPower;\n        } else {\n            proposal.noVotes += votingPower;\n        }\n        \n        // Award reputation for voting participation\n        bytes32 voteHash = keccak256(abi.encodePacked(\"vote\", _proposalId));\n        try reputationSystem.addVotingReputation(voterCitizenId, voteHash) {} catch {}\n        \n        emit VoteCast(_proposalId, voterCitizenId, msg.sender, _support, votingPower);\n        \n        // Check if proposal can be executed early\n        _checkProposalExecution(_proposalId);\n    }\n    \n    /**\n     * @dev Execute proposal after voting period ends\n     */\n    function executeProposal(uint256 _proposalId) external validProposalId(_proposalId) {\n        Proposal storage proposal = proposals[_proposalId];\n        require(proposal.status == ProposalStatus.ACTIVE, \"Voting: Proposal not active\");\n        require(block.timestamp > proposal.votingEndTimestamp || _canExecuteEarly(_proposalId), \n                \"Voting: Voting period not ended and cannot execute early\");\n        require(!proposal.isExecuted, \"Voting: Proposal already executed\");\n        \n        ProposalStatus newStatus = _determineProposalResult(_proposalId);\n        proposal.status = newStatus;\n        proposal.executionTimestamp = block.timestamp;\n        proposal.isExecuted = true;\n        \n        emit ProposalExecuted(_proposalId, newStatus, proposal.yesVotes, proposal.noVotes);\n        \n        // If proposal passed, execute any on-chain actions\n        if (newStatus == ProposalStatus.PASSED && proposal.executionData.length > 0) {\n            _executeProposalActions(_proposalId);\n        }\n    }\n    \n    // View functions\n    function getProposal(uint256 _proposalId) external view validProposalId(_proposalId) returns (Proposal memory) {\n        return proposals[_proposalId];\n    }\n    \n    function getProposalVotes(uint256 _proposalId) external view validProposalId(_proposalId) returns (Vote[] memory) {\n        return proposalVotes[_proposalId];\n    }\n    \n    function getProposalsByType(ProposalType _proposalType) external view returns (uint256[] memory) {\n        return typeProposals[uint256(_proposalType)];\n    }\n    \n    function getCitizenProposals(address _citizen) external view returns (uint256[] memory) {\n        return citizenProposals[_citizen];\n    }\n    \n    function getActiveProposals() external view returns (uint256[] memory) {\n        uint256 count = 0;\n        \n        // Count active proposals\n        for (uint256 i = 1; i <= _proposalIdCounter; i++) {\n            if (proposals[i].status == ProposalStatus.ACTIVE && \n                block.timestamp <= proposals[i].votingEndTimestamp) {\n                count++;\n            }\n        }\n        \n        // Create result array\n        uint256[] memory activeProposals = new uint256[](count);\n        uint256 index = 0;\n        \n        for (uint256 i = 1; i <= _proposalIdCounter; i++) {\n            if (proposals[i].status == ProposalStatus.ACTIVE && \n                block.timestamp <= proposals[i].votingEndTimestamp) {\n                activeProposals[index] = i;\n                index++;\n            }\n        }\n        \n        return activeProposals;\n    }\n    \n    function getTotalProposals() external view returns (uint256) {\n        return _proposalIdCounter;\n    }\n    \n    function getVotingStats() external view returns (\n        uint256 totalProposals,\n        uint256 activeProposals,\n        uint256 passedProposals,\n        uint256 rejectedProposals\n    ) {\n        uint256 active = 0;\n        uint256 passed = 0;\n        uint256 rejected = 0;\n        \n        for (uint256 i = 1; i <= _proposalIdCounter; i++) {\n            ProposalStatus status = proposals[i].status;\n            \n            if (status == ProposalStatus.ACTIVE && block.timestamp <= proposals[i].votingEndTimestamp) {\n                active++;\n            } else if (status == ProposalStatus.PASSED) {\n                passed++;\n            } else if (status == ProposalStatus.REJECTED) {\n                rejected++;\n            }\n        }\n        \n        return (_proposalIdCounter, active, passed, rejected);\n    }\n    \n    // Internal functions\n    function _calculateVotingPower(uint256 _reputation) internal pure returns (uint256) {\n        // Base voting power with reputation multiplier\n        if (_reputation >= 1000) return 100;      // High reputation\n        else if (_reputation >= 500) return 50;   // Medium reputation\n        else if (_reputation >= 100) return 25;   // Basic reputation\n        else return 10;                           // Minimum voting power\n    }\n    \n    function _checkProposalExecution(uint256 _proposalId) internal {\n        if (_canExecuteEarly(_proposalId)) {\n            Proposal storage proposal = proposals[_proposalId];\n            ProposalStatus newStatus = _determineProposalResult(_proposalId);\n            proposal.status = newStatus;\n            proposal.executionTimestamp = block.timestamp;\n            proposal.isExecuted = true;\n            \n            emit ProposalExecuted(_proposalId, newStatus, proposal.yesVotes, proposal.noVotes);\n        }\n    }\n    \n    function _canExecuteEarly(uint256 _proposalId) internal view returns (bool) {\n        Proposal storage proposal = proposals[_proposalId];\n        \n        // Early execution if quorum met and overwhelming majority\n        if (proposal.totalVotingPower >= proposal.quorumRequired) {\n            uint256 yesPercentage = (proposal.yesVotes * 10000) / proposal.totalVotingPower;\n            return yesPercentage >= 8000; // 80% majority allows early execution\n        }\n        \n        return false;\n    }\n    \n    function _determineProposalResult(uint256 _proposalId) internal view returns (ProposalStatus) {\n        Proposal storage proposal = proposals[_proposalId];\n        \n        // Check quorum\n        if (proposal.totalVotingPower < proposal.quorumRequired) {\n            return ProposalStatus.EXPIRED;\n        }\n        \n        // Check passing threshold\n        uint256 yesPercentage = (proposal.yesVotes * 10000) / proposal.totalVotingPower;\n        return yesPercentage >= proposal.passingThreshold ? ProposalStatus.PASSED : ProposalStatus.REJECTED;\n    }\n    \n    function _executeProposalActions(uint256 _proposalId) internal {\n        // Implementation for executing proposal-specific actions\n        // This could include updating project registry, treasury allocations, etc.\n        Proposal storage proposal = proposals[_proposalId];\n        \n        if (proposal.proposalType == ProposalType.PROJECT_APPROVAL && proposal.relatedProjectId > 0) {\n            // Could trigger project status update in project registry\n            // projectRegistry.updateProjectStatus(proposal.relatedProjectId, ProjectStatus.APPROVED);\n        }\n    }\n    \n    // Admin functions\n    function updateVotingConfig(\n        uint256 _defaultVotingPeriod,\n        uint256 _minimumQuorum,\n        uint256 _defaultPassingThreshold,\n        uint256 _minimumReputationToPropose,\n        uint256 _minimumReputationToVote\n    ) external onlyOwner {\n        require(_defaultPassingThreshold >= 5000 && _defaultPassingThreshold <= 10000, \n                \"Voting: Invalid passing threshold\");\n        \n        defaultVotingPeriod = _defaultVotingPeriod;\n        minimumQuorum = _minimumQuorum;\n        defaultPassingThreshold = _defaultPassingThreshold;\n        minimumReputationToPropose = _minimumReputationToPropose;\n        minimumReputationToVote = _minimumReputationToVote;\n    }\n    \n    function cancelProposal(uint256 _proposalId) external validProposalId(_proposalId) {\n        require(\n            proposals[_proposalId].creator == msg.sender || msg.sender == owner(),\n            \"Voting: Not authorized to cancel\"\n        );\n        require(proposals[_proposalId].status == ProposalStatus.ACTIVE, \"Voting: Proposal not active\");\n        \n        ProposalStatus oldStatus = proposals[_proposalId].status;\n        proposals[_proposalId].status = ProposalStatus.CANCELLED;\n        \n        emit ProposalStatusChanged(_proposalId, oldStatus, ProposalStatus.CANCELLED);\n    }\n    \n    function updateReputationSystem(address _reputationSystem) external onlyOwner {\n        require(_reputationSystem != address(0), \"Voting: Invalid reputation system\");\n        reputationSystem = ReputationSystem(_reputationSystem);\n    }\n    \n    function updateProjectRegistry(address _projectRegistry) external onlyOwner {\n        require(_projectRegistry != address(0), \"Voting: Invalid project registry\");\n        projectRegistry = GovernmentProjectRegistry(_projectRegistry);\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}