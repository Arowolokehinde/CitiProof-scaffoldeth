"use client";

import React, { useCallback, useState } from "react";
import { useIpfsUpload } from "../../hooks/useIpfs";
import { useDropzone } from "react-dropzone";

interface IpfsUploaderProps {
  onUploadComplete: (hash: string, file: File) => void;
  onUploadError?: (error: string) => void;
  acceptedFileTypes?: string[];
  maxFileSize?: number;
  multiple?: boolean;
  className?: string;
}

export function IpfsUploader({
  onUploadComplete,
  onUploadError,
  acceptedFileTypes = ["image/*", "application/pdf", "text/*"],
  maxFileSize = 50 * 1024 * 1024, // 50MB default
  multiple = false,
  className = "",
}: IpfsUploaderProps) {
  const { uploadFile, loading, error } = useIpfsUpload();
  const [uploadProgress, setUploadProgress] = useState<{ [key: string]: number }>({});

  const handleFileUpload = useCallback(async (files: File[]) => {
    for (const file of files) {
      try {
        setUploadProgress(prev => ({ ...prev, [file.name]: 0 }));

        // Simulate progress for better UX (IPFS doesn't provide real progress)
        const progressInterval = setInterval(() => {
          setUploadProgress(prev => ({
            ...prev,
            [file.name]: Math.min((prev[file.name] || 0) + 10, 90),
          }));
        }, 100);

        const hash = await uploadFile(file);

        clearInterval(progressInterval);
        setUploadProgress(prev => ({ ...prev, [file.name]: 100 }));

        // Small delay to show 100% before removing
        setTimeout(() => {
          setUploadProgress(prev => {
            const newProgress = { ...prev };
            delete newProgress[file.name];
            return newProgress;
          });
        }, 1000);

        onUploadComplete(hash, file);
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : "Upload failed";
        onUploadError?.(errorMessage);
        setUploadProgress(prev => {
          const newProgress = { ...prev };
          delete newProgress[file.name];
          return newProgress;
        });
      }
    }
  }, [uploadFile, onUploadComplete, onUploadError]);

  const onDrop = useCallback((acceptedFiles: File[]) => {
    handleFileUpload(acceptedFiles);
  }, [handleFileUpload]);

  // Convert acceptedFileTypes to the format expected by react-dropzone v14+
  const acceptObject = acceptedFileTypes.length > 0 ? 
    acceptedFileTypes.reduce((acc, type) => {
      if (type.includes('/')) {
        // Handle MIME types like 'image/jpeg', 'application/pdf'
        acc[type] = [];
      } else if (type.includes('*')) {
        // Handle wildcard types like 'image/*'
        acc[type] = [];
      }
      return acc;
    }, {} as Record<string, string[]>) : 
    undefined;

  const { getRootProps, getInputProps, isDragActive, fileRejections } = useDropzone({
    onDrop,
    accept: acceptObject,
    maxSize: maxFileSize,
    multiple,
    noClick: false,
    noKeyboard: false,
  });

  const hasUploadProgress = Object.keys(uploadProgress).length > 0;

  return (
    <div className={`ipfs-uploader ${className}`}>
      <div
        {...getRootProps()}
        className={`border-2 border-dashed rounded-lg p-6 text-center cursor-pointer transition-colors
          ${isDragActive ? "border-blue-500 bg-blue-50" : "border-gray-300 hover:border-gray-400"}
          ${loading ? "pointer-events-none opacity-50" : ""}
        `}
      >
        <input {...getInputProps()} />

        <div className="space-y-4">
          <svg className="mx-auto h-12 w-12 text-gray-400" stroke="currentColor" fill="none" viewBox="0 0 48 48">
            <path
              d="M28 8H12a4 4 0 00-4 4v20m32-12v8m0 0v8a4 4 0 01-4 4H12a4 4 0 01-4-4v-4m32-4l-3.172-3.172a4 4 0 00-5.656 0L28 28M8 32l9.172-9.172a4 4 0 015.656 0L28 28m0 0l4 4m4-24h8m-4-4v8m-12 4h.02"
              strokeWidth={2}
              strokeLinecap="round"
              strokeLinejoin="round"
            />
          </svg>

          {isDragActive ? (
            <p className="text-blue-600">Drop files here to upload to IPFS...</p>
          ) : (
            <div>
              <p className="text-gray-600">
                Drag and drop files here, or <span className="text-blue-600 font-medium">click to browse</span>
              </p>
              <p className="text-sm text-gray-500 mt-1">
                Supports: {acceptedFileTypes.join(", ")} | Max: {Math.round(maxFileSize / (1024 * 1024))}MB
                {multiple && " | Multiple files allowed"}
              </p>
            </div>
          )}

          {loading && !hasUploadProgress && (
            <div className="flex items-center justify-center space-x-2">
              <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
              <span className="text-sm text-gray-600">Uploading to IPFS...</span>
            </div>
          )}
        </div>
      </div>

      {/* Upload Progress */}
      {hasUploadProgress && (
        <div className="mt-4 space-y-2">
          {Object.entries(uploadProgress).map(([fileName, progress]) => (
            <div key={fileName} className="bg-gray-50 rounded-lg p-3">
              <div className="flex items-center justify-between text-sm">
                <span className="font-medium text-gray-700 truncate flex-1 mr-2">{fileName}</span>
                <span className="text-gray-500">{progress}%</span>
              </div>
              <div className="w-full bg-gray-200 rounded-full h-2 mt-2">
                <div
                  className="bg-blue-600 h-2 rounded-full transition-all duration-300"
                  style={{ width: `${progress}%` }}
                />
              </div>
            </div>
          ))}
        </div>
      )}

      {/* File Rejection Errors */}
      {fileRejections.length > 0 && (
        <div className="mt-4 space-y-2">
          {fileRejections.map(({ file, errors }) => (
            <div key={file.name} className="bg-red-50 border border-red-200 rounded-lg p-3">
              <p className="text-sm font-medium text-red-800">{file.name}</p>
              <ul className="text-sm text-red-600 mt-1">
                {errors.map(error => (
                  <li key={error.code}>â€¢ {error.message}</li>
                ))}
              </ul>
            </div>
          ))}
        </div>
      )}

      {/* Upload Error */}
      {error && (
        <div className="mt-4 bg-red-50 border border-red-200 rounded-lg p-3">
          <p className="text-sm text-red-800">Upload failed: {error}</p>
        </div>
      )}
    </div>
  );
}

interface IpfsHashDisplayProps {
  hash: string;
  showGatewayLink?: boolean;
  className?: string;
}

export function IpfsHashDisplay({ hash, showGatewayLink = true, className = "" }: IpfsHashDisplayProps) {
  const [copied, setCopied] = useState(false);

  const copyToClipboard = async () => {
    try {
      await navigator.clipboard.writeText(hash);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    } catch (err) {
      console.error("Failed to copy hash:", err);
    }
  };

  return (
    <div className={`ipfs-hash-display ${className}`}>
      <div className="bg-gray-50 rounded-lg p-3 border">
        <div className="flex items-center justify-between">
          <div className="flex-1 min-w-0">
            <p className="text-xs text-gray-500 mb-1">IPFS Hash</p>
            <p className="text-sm font-mono text-gray-800 truncate">{hash}</p>
          </div>
          <button
            onClick={copyToClipboard}
            className="ml-3 p-1 text-gray-500 hover:text-gray-700 transition-colors"
            title="Copy hash"
          >
            {copied ? (
              <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                <path
                  fillRule="evenodd"
                  d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z"
                  clipRule="evenodd"
                />
              </svg>
            ) : (
              <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"
                />
              </svg>
            )}
          </button>
        </div>

        {showGatewayLink && (
          <div className="mt-3 pt-3 border-t border-gray-200">
            <a
              href={`https://ipfs.io/ipfs/${hash}`}
              target="_blank"
              rel="noopener noreferrer"
              className="text-sm text-blue-600 hover:text-blue-800 flex items-center"
            >
              View on IPFS Gateway
              <svg className="w-3 h-3 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"
                />
              </svg>
            </a>
          </div>
        )}
      </div>
    </div>
  );
}

export default IpfsUploader;
